/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/algebra/MonadicIteratorMap.js":
/*!**********************************************!*\
  !*** ./src/js/algebra/MonadicIteratorMap.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MonadicIteratorMap: () => (/* binding */ MonadicIteratorMap)\n/* harmony export */ });\n/**\n * @template {*} T\n * @template {*} G\n * @callback SimpleMapping\n * @param {T} value\n * @returns {G}\n */\n\n\n/**\n * @template {*} T\n * @template {*} G\n */\nclass LiftIterator {\n    /**\n     * @param {Iterable<T>} sourceIterable \n     * @param {SimpleMapping.<T, Iterable<G>>} f\n     */\n    constructor(sourceIterable, f) {\n        this.sourceIterable = sourceIterable[Symbol.iterator]();\n        this.f = f;\n        /**\n         * @type {Iterator<G,any> | undefined}\n         */\n        this._current = undefined;\n    }\n\n    /**\n     * @returns {IteratorResult<G, *>}\n     */\n    next = () => {\n        for(let i = 0;i < 500;i++) {\n            if(!this._current) {\n                const {done, value} = this.sourceIterable.next();\n                if(done) {\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                } else {\n                    this._current = this.f(value)[Symbol.iterator]();\n                    if(!this._current) {\n                        throw \"Undefined result of iterator\";\n                    }\n                }\n            } else {\n                const { done, value } = this._current.next();\n                if(done) {\n                    this._current = undefined;\n                } else {\n                    return {\n                        done: false,\n                        value\n                    };\n                }\n            }\n        }\n        throw \"Acquiring next iterator failed after 500 iterations...\";\n    };\n\n    [Symbol.iterator] = () => this;\n}\n\n\n/**\n * @template {*} T\n * @template {*} G\n * @param {SimpleMapping.<T,Iterable<G>>} f\n * @returns {SimpleMapping<Iterable<T>, Iterable<G>>}\n */\nfunction lift(f) {\n    /**\n     * @param {Iterable<T>} value\n     * @returns {Iterable<G>}\n     */\n    return value => new LiftIterator(value, f);\n}\n\n/**\n * @template {unknown} U\n * @template {unknown} V\n */\nclass MonadicIteratorMap {\n    /**\n     * @typedef {SimpleMapping.<*, Iterable<*>>} KleisliArrow\n     */\n    constructor() {\n        /**\n         * @type {Array.<KleisliArrow>} \n         */\n        this.functionStack = [];\n    }\n\n    /**\n     * @template {unknown} W\n     * @param {SimpleMapping.<V, W>} f\n     * @returns {MonadicIteratorMap.<U, W>}\n     */\n    map(f) {\n        /**\n         * @type {KleisliArrow}\n         */\n        const arrow = x => [f(x)];\n        \n        return (\n            /**\n             * @type {MonadicIteratorMap.<U, W>}\n             */ (new MonadicIteratorMap())\n        ).#withMarkers(...this.functionStack, arrow);\n    }\n\n    /**\n     * @template {unknown} W\n     * @param {SimpleMapping.<V, Iterable<W>>} f\n     * @returns {MonadicIteratorMap.<U, W>}\n     */\n    flatMap(f) {\n        /**\n         * @type {KleisliArrow}\n         */\n        const arrow = f;\n        \n        return (\n            /**\n             * @type {MonadicIteratorMap.<U, W>}\n             */ (new MonadicIteratorMap())\n        ).#withMarkers(...this.functionStack, arrow);\n    }\n\n    /**\n     * @template {unknown} W\n     * @param {SimpleMapping.<V, boolean>} f\n     * @returns {MonadicIteratorMap.<U, W>}\n     */\n    filter(f) {\n        /**\n         * @type {KleisliArrow}\n         */\n        const arrow = x => f(x) ? [x] : [];\n        \n        return (\n            /**\n             * @type {MonadicIteratorMap.<U, W>}\n             */ (new MonadicIteratorMap())\n        ).#withMarkers(...this.functionStack, arrow);\n    }\n\n    debug() {\n        return this.filter(_ => {\n            console.log(_);\n            return true;\n        });\n    }\n\n    /**\n     * @param {Iterable<U>} sourceIterable\n     * @returns {Iterable<V>}\n     */\n    apply(sourceIterable) {\n        /**\n         * @type {Iterable<unknown>}\n         */\n        let resultIterable = sourceIterable;\n        for(const arrow of this.functionStack) {\n            resultIterable = lift(arrow)(resultIterable);\n        }\n        \n        return (\n            /**\n             * @type {Iterable<V>}\n             */ (resultIterable)\n        );\n    }\n\n    /**\n     * @param  {...KleisliArrow} fs\n     */\n    #withMarkers(...fs) {\n        this.functionStack = fs;\n        return this;\n    }\n}\n\n\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/algebra/MonadicIteratorMap.js?");

/***/ }),

/***/ "./src/js/backend.js":
/*!***************************!*\
  !*** ./src/js/backend.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   backend: () => (/* binding */ backend)\n/* harmony export */ });\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date-utils */ \"./src/js/date-utils.js\");\n\n\n/**\n * ============================================================================\n * ======================================  EVENT STRUCTURES AND VERSIONING  ===\n * ============================================================================\n * \n * @typedef {{\n *  kind: 'cursor_move',\n *  userInitiator: string | undefined,\n *  cursor: number,\n *  version: 1\n * }} EventV1_CursorMove\n* ----------------------------------------------------------------------------\n * \n * @typedef {{\n *  kind: 'create',\n *  strDate: string,\n *  strTime: string,\n *  strDescription: string,\n *  strDetails: string | undefined,\n *  isDayOff: boolean | undefined,\n *  userInitiator: string | undefined,\n *  version: 1\n * }} EventV1_Create\n* ----------------------------------------------------------------------------\n * \n * @typedef {{\n *  kind: 'cancel',\n *  strDate: string,\n *  strTime: string,\n *  userInitiator: string | undefined,\n *  version: 1\n * }} EventV1_Cancel\n * ----------------------------------------------------------------------------\n * \n * @typedef {{\n *  toCancel: EventV1_Cancel,\n *  toCreate: EventV1_Create,\n *  version: 2\n * }} EventV2_Modify\n * ----------------------------------------------------------------------------\n * \n * Summary of all types, through the union `CalendarEvent`.\n * \n * @typedef {EventV1_CursorMove |\n *               EventV1_Create |\n *               EventV2_Modify |\n *               EventV1_Cancel } CalendarEvent\n * ----------------------------------------------------------------------------\n */\n\n\n/**\n * ============================================================================\n * =====================================================  CALENDAR EFFECTS  ===\n * ============================================================================\n * \n * Calendar effects refer to how events (as typed through `CalendarEvent`)\n * \n * @callback PatchCursorEffect\n * @param {number} cursorCandidate\n * ----------------------------------------------------------------------------\n * \n * @callback CreateEventEffect\n * @param {TemporalKey} temporalKey - [strDate, strTime]\n * @param {{\n *  description: string,\n *  details: string | undefined,\n *  isDayOff: boolean,\n *  hitTime: number\n * }} details - event details\n * ----------------------------------------------------------------------------\n * \n * @callback DeleteEventEffect\n * @param {TemporalKey} temporalKey - [strDate, strTime]\n * ----------------------------------------------------------------------------\n * \n * @typedef {{\n *  patchCursor: PatchCursorEffect,\n *  createEvent: CreateEventEffect,\n *  deleteEvent: DeleteEventEffect\n * }} Calendar\n * \n * @callback CalendarEffect\n * @param {Calendar} calendar\n * ----------------------------------------------------------------------------\n */\n\n\n/**\n * @param {EventV1_CursorMove | EventV1_Cancel | EventV1_Create} event\n * @param {number | undefined} hitTime\n * @param {string} [currentUser]\n * @returns {CalendarEffect | undefined} - A side effect on the calendar\n * ----------------------------------------------------------------------------\n */\nfunction eventV1Handle(event, hitTime, currentUser) {\n    const { kind, userInitiator } = event;\n    if (kind === 'cursor_move') {\n        const { cursor } = event;\n\n        if (userInitiator && userInitiator === currentUser) {\n            return ({ patchCursor }) => patchCursor(parseInt(String(cursor)));\n        } else {\n            return undefined;\n        }\n    } else {\n        const date = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(event.strDate);\n        const time = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateTimeString)(event.strTime);\n\n\n        if(!date || !time) {\n            return undefined;\n        } else {\n            if (kind === 'create') {\n                const { strDescription, strDetails, isDayOff } = event;\n                if (!strDescription) {\n                    return undefined;\n                } else {\n                    const reportTime = (\n                        userInitiator && userInitiator !== currentUser\n                    ) ? (hitTime || 0) : 0;\n\n                    return ({ createEvent }) => createEvent(\n                        { date, time },\n                        {\n                            description: strDescription,\n                            details: strDetails || undefined,\n                            isDayOff: isDayOff || false,\n                            hitTime: reportTime\n                        }\n                    );\n                }\n            } else if (kind === 'cancel') {\n                return ({ deleteEvent }) => deleteEvent({ date, time });\n            } else {\n                return undefined;\n            }\n        }\n    }\n}\n\n/**\n * \n * @param {EventV2_Modify} event \n * @param {number} time \n * @param {string} [currentUser] \n * @returns {CalendarEffect | undefined} - A side effect on the calendar\n *-----------------------------------------------------------------------------\n */\nfunction eventV2Handle(event, time, currentUser) {\n    const { toCancel, toCreate } = event;\n\n    const h1 = eventV1Handle(toCancel, time, currentUser);\n    const h2 = eventV1Handle(toCreate, time, currentUser);\n\n    if (h1 && h2) {\n        return x => { h1(x); h2(x); };\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * @param {CalendarEvent | undefined} event \n * @param {number} time \n * @param {string} [currentUser] \n * @returns {CalendarEffect | undefined}\n *-----------------------------------------------------------------------------\n */\nfunction eventHandler(event, time, currentUser) {\n    if (event) {\n        const { version } = event;\n        switch (version) {\n            case 1:\n                return eventV1Handle(event, time, currentUser);\n            case 2:\n                return eventV2Handle(event, time, currentUser);\n        }\n    }\n    return undefined;\n}\n\n/**\n * Sends messages and fetches information from the remote backend.\n * The policy here is agnostic of everything that relates to the business,\n * but is concerned with correct headers definition and token retrieve.\n * \n * @typedef {{\n *  from: number,\n *  password: string | undefined,\n *  newEvent: CalendarEvent | undefined\n * }} FetchRoutineArgument\n * \n * @param {FetchRoutineArgument} _1 \n * @returns {Promise<Response>}\n * ----------------------------------------------------------------------------\n */\nasync function fetchRoutine(_1) {\n    const { from, password, newEvent } = _1;\n    const url = '/send_event.php?from=' + String(from);\n\n    /**\n     * @type {string | undefined}\n     */\n    const csrfToken = (\n        /**\n         * @type{Object.<string,string>}\n         */ (\n            /**\n             * @type{Object}\n             */ (window)\n        )['__csrfToken']\n    );\n\n    /**\n     * @type {HeadersInit}\n     */\n    const headers = { 'Accept': 'application/json' };\n    if (csrfToken) { headers['X-Csrf-Token'] = csrfToken; }\n    if (password) { headers['Authentication'] = btoa(password); }\n\n    /**\n     * @type {Response}\n     */\n    let response;\n    if (newEvent) {\n        headers['Content-Type'] = 'application/json';\n        response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(newEvent)\n        });\n    } else {\n        response = await fetch(url, {\n            method: 'GET',\n            headers\n        });\n    }\n\n    if (response.status !== 200) {\n        const authDelay = response.headers.get(\"X-Authentication-Delay\");\n        throw {\n            errorCode: response.status,\n            authenticationDelay: authDelay,\n            errorMessage: await response.json()\n        };\n    } else {\n        return response;\n    }\n}\n\n/**\n * Sends messages and fetches information from the remote backend.\n * Compared to `fetchRoutine`, this method is aware of the business and\n * performs a paginated fetch. It also decrypts events as effects on the\n * calendar, using the `eventHandler` routine.\n * \n * @callback Continuation\n * @returns {Promise<number | undefined>}\n * \n * @param {FetchRoutineArgument} x \n * @param {Calendar} calendar \n * @returns {Promise<Continuation>}\n * ----------------------------------------------------------------------------\n */\nasync function sendEvent(x, calendar) {\n    /**\n     * @param {Iterable<\n     *  [CalendarEvent | undefined, number] | undefined\n     * >} content\n     * @returns {unknown}\n     */\n    function consumeContent(content) {\n        if (content) {\n            const currentUser = window.localStorage.getItem('userName');\n\n            const effects = [];\n            for (const record of content) {\n                if (record) {\n                    const [eventData, time] = record;\n                    if (time) {\n                        const effect = eventHandler(\n                            eventData, time, currentUser || undefined\n                        );\n                        if (effect) {\n                            effects.push(effect);\n                        }\n                    }\n                }\n            }\n            for (const effect of effects) {\n                effect(calendar);\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @param {Response} response \n     * @returns {Promise<number | undefined>}\n     * ------------------------------------------------------------------------\n     */\n    async function continuationOf(response) {\n        let from;\n        for (let responseCursor = response; ;) {\n            const nextTime = parseInt(\n                responseCursor.headers.get('x-next-page-time') || '0'\n            );\n            if (!nextTime || !isFinite(nextTime)) {\n                consumeContent(await responseCursor.json());\n                break;\n            } else {\n                from = nextTime;\n                [responseCursor] = await Promise.all([\n                    fetchRoutine({\n                        from: nextTime,\n                        password: undefined, newEvent: undefined\n                    }),\n                    responseCursor.json().then(consumeContent)\n                ]);\n            }\n        }\n        return from;\n    }\n\n    const firstResponse = await fetchRoutine(x);\n    return () => continuationOf(firstResponse);\n}\n\n\nclass Backend {\n    constructor() {\n        /**\n         * @type {Map<DateString, Map<TimeString, EventData>>}\n         */\n        this.view = new Map();\n\n        /**\n         * @type {Array<{hitTime: number} & TemporalKey>}\n         */\n        this.newEvents = [];\n        this.userCursor = 0;\n        this.isBusy = false;\n        this.lastUpdateTimestamp = 0;\n    }\n\n    #getState() {\n        if (!this.authentifiedUser.userName) {\n            throw {\n                errorMessage: \"Utilisateur non identifié\",\n                errorCode: 403\n            };\n        }\n        return {\n            view: this.view,\n            newEvents: [\n                ... new Set(this.newEvents.map(_date_utils__WEBPACK_IMPORTED_MODULE_0__.glueTemporalKey))\n            ].map(expression => {\n                const { date, time } = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.unglueTemporalKey)(expression);\n                return {\n                    strDate: date,\n                    strTime: time\n                };\n            })\n        };\n    }\n\n    /**\n     * @param {TemporalKey} _1 \n     * ------------------------------------------------------------------------\n     */\n    #deleteEvent(_1) {\n        const { date, time } = _1;\n\n        const timeMap = this.view.get(date);\n        if (timeMap) {\n            timeMap.delete(time);\n\n            if (!timeMap.size) {\n                this.view.delete(date);\n            }\n        }\n    }\n\n    /**\n     * @param {TemporalKey} _1\n     * @param {{\n     *  description: string,\n     *  details: string | undefined,\n     *  hitTime: number,\n     *  isDayOff: boolean\n     * }} _2 \n     * ------------------------------------------------------------------------\n     */\n    #createEvent(_1, _2) {\n        const { date, time } = _1;\n        const { description, details, hitTime, isDayOff } = _2;\n\n        const entry = {\n            description, details, isDayOff,\n            unread: hitTime && hitTime > this.userCursor ? true : false\n        };\n\n        this.view.set(date, (\n            this.view.get(date) || new Map()\n        ).set(time, entry));\n\n        if (entry.unread) {\n            this.newEvents.push({\n                hitTime,\n                time,\n                date\n            });\n        }\n    }\n\n    /**\n     * \n     * @callback IsReadPredicate\n     * @param {{hitTime: number | undefined, date: DateString | undefined}} _\n     * @returns {boolean}\n     */\n\n    /**\n     * @param {IsReadPredicate} isReadPredicate \n     */\n    #markEventsAsRead(isReadPredicate) {\n        const newEvents = [];\n\n        for (const elem of this.newEvents) {\n            const { date, time } = elem;\n            const mapEntry = new Map(this.view.get(date)).get(time);\n            if(mapEntry) {\n                if(isReadPredicate(elem)) {\n                    mapEntry.unread = false;\n                } else {\n                    newEvents.push(elem);\n                }\n            }\n        }\n        this.newEvents = newEvents;\n    }\n\n    /**\n     * @param {number} cursor \n     */\n    #patchCursor(cursor) {\n        if (!isNaN(cursor)) {\n            const effectiveCursor = Math.max(this.userCursor, cursor);\n\n            this.#markEventsAsRead(\n                ({ hitTime }) => (hitTime || -1) <= effectiveCursor\n            );\n        }\n    }\n\n    /**\n     * @param {{\n     *  password: string | undefined\n     *  newEvent: CalendarEvent | undefined\n     * }} _1\n     */\n    async #update(_1) {\n        const { password, newEvent } = _1;\n        try {\n            if (this.isBusy) {\n                return false;\n            } else {\n                this.isBusy = true;\n                try {\n                    const continuation = await sendEvent(\n                        {\n                            password,\n                            newEvent,\n                            from: this.userCursor\n                        }, {\n                        patchCursor: this.#patchCursor.bind(this),\n                        deleteEvent: this.#deleteEvent.bind(this),\n                        createEvent: this.#createEvent.bind(this),\n                    }\n                    );\n\n                    const nextCursor = await continuation();\n                    this.userCursor = nextCursor || this.userCursor;\n\n                    // We clean here the newEvents array,\n                    // to filter it only after the batch process\n                    const todayDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\n                    this.#markEventsAsRead(\n                        ({ date }) => (date || '') < todayDate\n                    );\n                    return true;\n                } finally {\n                    this.isBusy = false;\n                }\n            }\n        } catch (error) {\n            console.error(error);\n            throw error;\n        }\n    }\n\n    /** Exposed getters */\n\n    get state() {\n        return new Promise((res, rej) => {\n            const now = Date.now();\n            (async () => {\n                if (!this._Backend__lastUpdateTimestamp ||\n                    this._Backend__lastUpdateTimestamp < now - 30 * 1000\n                ) {\n                    try {\n                        await this.#update({\n                            password: undefined,\n                            newEvent: undefined\n                        });\n                        this._Backend__lastUpdateTimestamp = now;\n                    } catch (error) {\n                        rej(error);\n                    }\n                }\n                try {\n                    res(this.#getState());\n                } catch (error) {\n                    rej(error);\n                }\n            })();\n        });\n    }\n\n    get authentifiedUser() {\n        return {\n            userName: localStorage.getItem('userName') || undefined\n        };\n    }\n\n    /**\n     * \n     * @param {{\n     *  password: string | undefined,\n     *  userName: string | undefined\n     * }} credentials\n     * @returns {Promise<boolean>}\n     */\n    authentify = async credentials => {\n        const { password, userName } = credentials;\n        if (!userName) {\n            localStorage.removeItem('userName');\n        } else {\n            localStorage.setItem('userName', userName);\n        }\n        return this.#update({ password, newEvent: undefined });\n    };\n\n    /**\n     * @param {TemporalKey & {\n     *  strDescription: string,\n     *  strDetails: string | undefined,\n     *  isDayOff: boolean\n     * }} appointmentRecord \n     * @returns {Promise<boolean>}\n     */\n    createEvent = async (appointmentRecord) => {\n        const {\n            time, date,\n            strDescription, strDetails, isDayOff\n        } = appointmentRecord;\n        /**\n         * @type {EventV1_Create}\n         */\n        const newEvent = {\n            strTime: time,\n            strDate: date,\n            strDescription, strDetails, isDayOff,\n            userInitiator: (\n                window.localStorage.getItem('userName') || undefined\n            ),\n            kind: \"create\",\n            version: 1\n        };\n        return this.#update({ newEvent, password: undefined });\n    };\n\n    /**\n     * @param {TemporalKey} temporalKey\n     * @returns {Promise<boolean>}\n     */\n    cancelEvent = async (temporalKey) => {\n        const { date, time } = temporalKey;\n        /**\n         * @type {EventV1_Cancel}\n         */\n        const newEvent = {\n            strDate: date,\n            strTime: time,\n            userInitiator: (\n                window.localStorage.getItem('userName') || undefined\n            ),\n            version: 1,\n            kind: \"cancel\"\n        };\n\n        return this.#update({ newEvent, password: undefined });\n    };\n\n    /**\n     * @param {{\n     *  toCreate: TemporalKey & {\n     *   strDescription: string,\n     *   strDetails: string | undefined,\n     *   isDayOff: boolean\n     *  },\n     *  toCancel: TemporalKey\n     * }} modification \n     * @returns {Promise<boolean>}\n     */\n    editEvent = async (modification) => {\n        const { toCancel, toCreate } = modification;\n        const userInitiator = (\n            window.localStorage.getItem('userName') || undefined\n        );\n\n        /**\n         * @type {EventV1_Create}\n         */\n        const createEvent = (({\n            date, time,\n            strDescription, strDetails, isDayOff\n        }) => ({\n            strTime: time,\n            strDate: date,\n            strDescription, strDetails, isDayOff,\n            userInitiator,\n            version: 1,\n            kind: \"create\"\n        }))(toCreate);\n\n        /**\n         * @type {EventV1_Cancel}\n         */\n        const cancelEvent = (({ date, time }) => ({\n            strTime: time,\n            strDate: date,\n            version: 1,\n            kind: \"cancel\",\n            userInitiator\n        }))(toCancel);\n\n        /**\n         * @type {EventV2_Modify}\n         */\n        const newEvent = {\n            toCreate: createEvent,\n            toCancel: cancelEvent,\n            version: 2\n        };\n\n        return this.#update({ newEvent, password: undefined });\n    };\n\n    markRead = async () => {\n        /**\n         * @type {EventV1_CursorMove}\n         */\n        const newEvent = {\n            userInitiator: (\n                window.localStorage.getItem('userName') || undefined\n            ),\n            kind: \"cursor_move\",\n            version: 1,\n            cursor: this.userCursor\n        };\n        return this.#update({ newEvent, password: undefined });\n    };\n}\n\n\nconst backend = new Backend();\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/backend.js?");

/***/ }),

/***/ "./src/js/components/DayTwoDigits.js":
/*!*******************************************!*\
  !*** ./src/js/components/DayTwoDigits.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n\ncustomElements.define(\"app-day-two-digits\", class extends HTMLElement {\n    constructor() {\n        super();\n\n        /**\n         * @type {{\n         *  strdate: DateString | undefined\n         * }}\n         */\n        this.state = {\n            strdate: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strdate\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strdate')} name - The name of the attribute that changes\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const date = this.state.strdate;\n        if(date) {\n            this.textContent = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.dayOfDate)(date);\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n\n//# sourceURL=webpack://v4/./src/js/components/DayTwoDigits.js?");

/***/ }),

/***/ "./src/js/components/FrenchMonth.js":
/*!******************************************!*\
  !*** ./src/js/components/FrenchMonth.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n\n/**\n * Compute a French word that represents the month, from a given month,\n * as a string from '01' to '12'.\n * \n * @param {(\n*  '01'|'02'|'03'|'04'|'05'|'06'|'07'|'08'|'09'|'10'|'11'|'12'\n* )} month - The month\n* @returns {string} - The French name of the month\n*/\nfunction computeFrenchMonth(month)\n{\n    switch(month) {\n        case \"01\": return \"Janvier\";\n        case \"02\": return \"Février\";\n        case \"03\": return \"Mars\";\n        case \"04\": return \"Avril\";\n        case \"05\": return \"Mai\";\n        case \"06\": return \"Juin\";\n        case \"07\": return \"Juillet\";\n        case \"08\": return \"Août\";\n        case \"09\": return \"Septembre\";\n        case \"10\": return \"Octobre\";\n        case \"11\": return \"Novembre\";\n        case \"12\": return \"Décembre\";\n          default: return \"\";\n    }\n}\n\n\ncustomElements.define(\"app-french-month\", class extends HTMLElement {\n    constructor() {\n        super();\n\n        /**\n         * @type {{\n         *  strdate: DateString | undefined\n         * }}\n         */\n        this.state = {\n            strdate: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strdate\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strdate')} name - The name of the attribute that changes\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const date = this.state.strdate;\n        if(date) {\n            const frenchMonth = computeFrenchMonth((0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.monthOfDate)(date));\n            this.textContent = frenchMonth;\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n\n//# sourceURL=webpack://v4/./src/js/components/FrenchMonth.js?");

/***/ }),

/***/ "./src/js/components/LongFrenchDate.js":
/*!*********************************************!*\
  !*** ./src/js/components/LongFrenchDate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n\n/**\n * Compute a French word that represents the month, from a given month,\n * as a string from '01' to '12'.\n * \n * @param {(\n*  '01'|'02'|'03'|'04'|'05'|'06'|'07'|'08'|'09'|'10'|'11'|'12'\n* )} month - The month\n* @returns {string} - The French name of the month\n*/\nfunction computeFrenchMonth(month)\n{\n    switch(month) {\n        case \"01\": return \"Janvier\";\n        case \"02\": return \"Février\";\n        case \"03\": return \"Mars\";\n        case \"04\": return \"Avril\";\n        case \"05\": return \"Mai\";\n        case \"06\": return \"Juin\";\n        case \"07\": return \"Juillet\";\n        case \"08\": return \"Août\";\n        case \"09\": return \"Septembre\";\n        case \"10\": return \"Octobre\";\n        case \"11\": return \"Novembre\";\n        case \"12\": return \"Décembre\";\n          default: return \"\";\n    }\n}\n\n\n/**\n * Compute a French number from a day in month. This is done by turning\n * removing leading zeros, and in the case of '01', replacing with '1er'.\n * \n * @param {(\n *  '01'|'02'|'03'|'04'|'05'|'06'|'07'|'08'|'09'|'10'|\n*   '11'|'12'|'13'|'14'|'15'|'16'|'17'|'18'|'19'|'20'|\n*   '21'|'22'|'23'|'24'|'25'|'26'|'27'|'28'|'29'|'30'|'31'\n * )} day - The day\n * @returns {string} - The French representation of the day\n */\nfunction computeFrenchDay(day)\n{\n    switch(day) {\n        case \"01\": return \"1er\";\n        case \"02\": return \"2\";\n        case \"03\": return \"3\";\n        case \"04\": return \"4\";\n        case \"05\": return \"5\";\n        case \"06\": return \"6\";\n        case \"07\": return \"7\";\n        case \"08\": return \"8\";\n        case \"09\": return \"9\";\n          default: return day;\n    }\n}\n\n\ncustomElements.define(\"app-long-french-date\", class extends HTMLElement {\n    constructor() {\n        super();\n        /**\n         * @type {{\n         *  strdate: DateString | undefined,\n         *  case: string | undefined\n         * }}\n         */\n        this.state = {\n            strdate: undefined,\n            case: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strdate\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strdate')} name - The name of the attribute that changes\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const date = this.state.strdate;\n\n        if(date) {\n            const frenchMonth = computeFrenchMonth((0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.monthOfDate)(date));\n            const frenchDay = computeFrenchDay((0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.dayOfDate)(date));\n\n            if(frenchDay == '1er') {\n                this.innerHTML = `1<sup>er</sup> `;\n                this.appendChild(document.createTextNode(frenchMonth));\n            } else {\n                this.textContent = `${frenchDay} ${frenchMonth}`;\n            }\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n\n//# sourceURL=webpack://v4/./src/js/components/LongFrenchDate.js?");

/***/ }),

/***/ "./src/js/components/LongFrenchTime.js":
/*!*********************************************!*\
  !*** ./src/js/components/LongFrenchTime.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n/**\n * Computes a French fragment that best represents the time.\n * \n * @param {TimeString} strTime - The time to convert to French\n * @returns {string} A French version of the time.\n */\nfunction computeFrenchTime(strTime)\n{\n    switch(strTime) {\n        case   \"fullday\": return \"Toute la journée\";\n        case \"afternoon\": return \"En après-midi\";\n        case   \"morning\": return \"Au matin\";\n                 default: return `À ${strTime}`;\n    }\n}\n\n\ncustomElements.define(\"app-long-french-time\", class extends HTMLElement {\n    constructor() {\n        super();\n\n        /**\n         * @type {{\n         *  strtime: TimeString | undefined,\n         *  case: string | undefined\n         * }}\n         */\n        this.state = {\n            strtime: undefined,\n            case: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strtime\",\n            \"case\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strtime' | 'case')} name - The name of the changing attribute\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateTimeString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const time = this.state.strtime;\n        const letterCase = this.state.case;\n\n        if(time) {\n            let frenchTime = computeFrenchTime(time);\n            if(letterCase == 'lowercase') {\n                frenchTime = frenchTime.toLowerCase();\n            }\n\n            this.textContent = frenchTime;\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n\n//# sourceURL=webpack://v4/./src/js/components/LongFrenchTime.js?");

/***/ }),

/***/ "./src/js/components/MonthTwoDigits.js":
/*!*********************************************!*\
  !*** ./src/js/components/MonthTwoDigits.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n\ncustomElements.define(\"app-month-two-digits\", class extends HTMLElement {\n    constructor() {\n        super();\n\n        /**\n         * @type {{\n         *  strdate: DateString | undefined\n         * }}\n         */\n        this.state = {\n            strdate: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strdate\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strdate')} name - The name of the attribute that changes\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const date = this.state.strdate;\n        if(date) {\n            this.textContent = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.monthOfDate)(date);\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n//# sourceURL=webpack://v4/./src/js/components/MonthTwoDigits.js?");

/***/ }),

/***/ "./src/js/components/YearFourDigits.js":
/*!*********************************************!*\
  !*** ./src/js/components/YearFourDigits.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils */ \"./src/js/date-utils.js\");\n\n\n\ncustomElements.define(\"app-year-four-digits\", class extends HTMLElement {\n    constructor() {\n        super();\n\n        /**\n         * @type {{\n         *  strdate: DateString | undefined\n         * }}\n         */\n        this.state = {\n            strdate: undefined\n        };\n    }\n\n    static get observedAttributes() {\n        return [\n            \"strdate\"\n        ];\n    }\n\n    /**\n     * \n     * @param {('strdate')} name - The name of the attribute that changes\n     * @param {string | undefined} _oldValue - The previous value\n     * @param {string | undefined} newValue - The new value\n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        registerState: {\n            if(newValue) {\n                const maybeDate = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(newValue);\n                if(maybeDate) {\n                    this.state[name] = maybeDate;\n                    break registerState;\n                }\n            }\n            this.state[name] = undefined;\n        }\n        this.#paint();\n    }\n\n    #paint() {\n        const date = this.state.strdate;\n        if(date) {\n            this.textContent = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.yearOfDate)(date);\n        } else {\n            this.innerHTML = \"\";\n        }\n    }\n});\n\n//# sourceURL=webpack://v4/./src/js/components/YearFourDigits.js?");

/***/ }),

/***/ "./src/js/components/appointments-list/AbstractAppointmentsList.js":
/*!*************************************************************************!*\
  !*** ./src/js/components/appointments-list/AbstractAppointmentsList.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   forgeData: () => (/* binding */ forgeData),\n/* harmony export */   forgeTemplateScope: () => (/* binding */ forgeTemplateScope)\n/* harmony export */ });\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../date-utils */ \"./src/js/date-utils.js\");\n\n\n\n/**\n * @typedef {{\n *  strDate: DateString,\n *  strTime: TimeString,\n *  eventData: EventData\n * }} Appointment - A single record to represent an appointment\n * ----------------------------------------------------------------------------\n */\n\n/**\n * @typedef {{\n *  strDate: DateString,\n *  strTime: TimeString,\n *  strDescription: string,\n *  strDetails: string | undefined,\n *  isDayOff: boolean,\n *  markUnread: boolean,\n *  handleClick: ClickHandler\n * }} AppointmentListTemplateData\n * ----------------------------------------------------------------------------\n */\n\n/**\n * @param {Appointment} appointment \n * @param {NavigateToCallback} navigateTo \n * @return {AppointmentListTemplateData}\n * ----------------------------------------------------------------------------\n */\nfunction forgeData(appointment, navigateTo) {\n    const { strDate, strTime, eventData } = appointment;\n    const { description, details, isDayOff, unread } = eventData;\n    return {\n        strDate,\n        strTime,\n        strDescription: description,\n        strDetails: details,\n        isDayOff: isDayOff,\n        markUnread: unread,\n        handleClick: () => void navigateTo({\n            url: '/calendar/mutate/modify',\n            parameters: {\n                preferredDate: strDate,\n                preferredTime: strTime\n            }\n        })\n    };\n}\n\n/**\n * Reshape an iterable of appointments for `appointment-list` template.\n * \n * @param {Iterable<AppointmentListTemplateData>} appointments  - Template data\n * @param {{\n *  sort: boolean\n * }} [options] - Options for handling the list\n * @return {{\n *  appointments: Iterable<AppointmentListTemplateData>\n * }}\n * ----------------------------------------------------------------------------\n */\nfunction forgeTemplateScope(appointments, options={sort: false}) {\n    if(options.sort) {\n        const sortedAppointments = (\n            Array.isArray(appointments)\n                ? appointments : [...appointments]\n        ).sort((a,b) => {\n            if(a.strDate == b.strDate) {\n                return (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.strTimeSorting)(a.strTime, b.strTime);\n            } else {\n                return a.strDate < b.strDate ? -1 : 1;\n            }\n        });\n\n        return forgeTemplateScope(\n            sortedAppointments,\n            { sort: false }\n        );\n    } else {\n        return {\n            appointments\n        };\n    }\n}\n\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/components/appointments-list/AbstractAppointmentsList.js?");

/***/ }),

/***/ "./src/js/components/forms/AuthenticationForm.js":
/*!*******************************************************!*\
  !*** ./src/js/components/forms/AuthenticationForm.js ***!
  \*******************************************************/
/***/ (() => {

eval("/**\n * @callback AuthenticationFormSubmit\n * @param {SubmitFormAction<CredentialsInput>} action\n * @returns {Promise<unknown>}\n */\n\ncustomElements.define(\"app-authentication-form\", class extends HTMLElement {\n    static get observedAttributes()\n        { return ['username']; }\n        \n    constructor() {\n        super();\n        /**\n         * @type {{\n         *  formElement: HTMLFormElement,\n         *  passwordController: HTMLInputElement,\n         *  userNameController: HTMLInputElement,\n         *  errorArea: HTMLElement\n         * } | undefined}\n         */\n        this._cache = undefined;\n    }\n\n    connectedCallback() {\n        const formElement = this.#formElement;\n\n        /**\n         * @param {SubmitEvent} event \n         */\n        const submitListener = event => {\n            /**\n             * @type {AppEvent.<AuthenticationFormSubmit>}\n             */\n            const appEvent = { detail: this.submit };\n\n            event.preventDefault();\n            this.dispatchEvent(new CustomEvent(\"app-authentify\", appEvent));\n            return undefined;\n        };\n\n        formElement.addEventListener(\"submit\", submitListener);\n    }\n\n    /**\n     * @param {('strdate')} _name \n     * @param {string | undefined} _old \n     * @param {string | undefined} newValue \n     */\n    attributeChangedCallback(_name, _old, newValue) {\n        this.#userNameController.value = newValue || '';\n    }\n\n    get #cache() {\n        if(!this._cache) {\n            const formElement = (\n                /**\n                 * @type { HTMLFormElement}\n                 */ (this.querySelector(\"form\"))\n            );\n            this._cache = (\n                /**\n                 * @type {{\n                 *  formElement: HTMLFormElement,\n                 *  passwordController: HTMLInputElement,\n                 *  userNameController: HTMLInputElement,\n                 *  errorArea: HTMLElement\n                 * }}\n                 */ ({\n                    formElement,\n                    passwordController: formElement['password'],\n                    userNameController: formElement['identity'],\n                    errorArea: this.querySelector(\"*[data-id=error-feedback]\")\n                 })\n            );\n        }\n        return this._cache;\n    }\n\n    get #formElement() {\n        return this.#cache.formElement;\n    }\n\n    get #userNameController() {\n        return this.#cache.userNameController;\n    }\n\n    get #passwordController() {\n        return this.#cache.passwordController;\n    }\n\n    get #errorArea() {\n        return this.#cache.errorArea;\n    }\n\n    /**\n     * @param {SubmitFormAction<CredentialsInput>} action\n     * @returns {Promise<unknown>}\n     */\n    submit = async (action) => {\n        this.#errorArea.innerHTML = \"\";\n        this.#userNameController.disabled = true;\n        this.#passwordController.disabled = true;\n        \n        try {\n            const credentials = {\n                password: this.#passwordController.value || '',\n                userName: this.#userNameController.value || ''\n            };\n            await action(credentials);\n        } catch(error) {\n            const backendError = (\n                /**\n                 * @type {BackendError}\n                 */ (error)\n            );\n            const { errorCode } = backendError;\n            if(errorCode && errorCode >= 400) {\n                this.#errorArea.textContent = backendError.errorMessage;\n            }\n        } finally {\n            this.#userNameController.disabled = false;\n            this.#passwordController.disabled = false;\n            this.#passwordController.focus();\n            this.#passwordController.select();\n        }\n        return undefined;\n    };\n});\n\n//# sourceURL=webpack://v4/./src/js/components/forms/AuthenticationForm.js?");

/***/ }),

/***/ "./src/js/components/forms/CalendarMutationForm.js":
/*!*********************************************************!*\
  !*** ./src/js/components/forms/CalendarMutationForm.js ***!
  \*********************************************************/
/***/ (() => {

eval("/**\n * \n * @param {string} strTime \n * @returns {string}\n */\nfunction timeRangeOf(strTime)\n{\n    switch(strTime) {\n        case \"fullday\":\n        case \"morning\":\n        case \"afternoon\":\n            return strTime;\n        default:\n            return '';\n    }\n}\n\n/**\n * \n * @param {string} strTime \n * @returns {string}\n */\nfunction timeNumericOf(strTime) {\n    switch(strTime) {\n        case \"fullday\":\n        case \"morning\":\n        case \"afternoon\":\n            return '';\n        default:\n            return strTime;\n    }\n}\n\n\ncustomElements.define(\"app-calendar-mutation-form\", class extends HTMLElement {\n    static get observedAttributes() {\n        return [\n            'preferred-date',\n            'preferred-time',\n            'preferred-description',\n            'preferred-details',\n            'preferred-is-day-off'\n        ];\n    }\n    constructor() {\n        super();\n\n        this._cache = undefined;\n        this._value = {\n            date: '',\n            timeNumeric: '',\n            timeRange: '',\n            isDayOff: false,\n            description: '',\n            details: ''\n        };\n    }\n\n    connectedCallback() {\n        const {\n            formController,\n            dateController,\n            timeRangeController,\n            timeNumericController,\n            isDayOffController,\n            cancelController\n        } = this.#cache;\n\n        formController.addEventListener(\"submit\", event => {\n            event.preventDefault();\n            this.dispatchEvent(new CustomEvent(\n                \"app-calendar-mutation-form-submit\",\n                {\n                    detail: this.submit\n                }\n            ));\n        });\n\n        for(const controller of [\n            dateController,\n            timeRangeController,\n            timeNumericController,\n            isDayOffController\n        ]) {\n            controller.addEventListener(\"change\", () => {\n                this.#rectifyAfterChange();\n                this.#emitChange();\n            });\n        }\n\n        if(cancelController) {\n            cancelController.addEventListener(\"change\", () => {\n                this.#rectifyAfterCancelStateChange();\n                this.#emitChange();\n            });\n            cancelController.checked = false;\n            cancelController.disabled = false;\n        }\n\n        this.#rectifyAfterLoad();\n    }\n\n    /**\n     * \n     * @param {(\n     *  'preferred-date' |\n     *  'preferred-time' |\n     *  'preferred-description' |\n     *  'preferred-details' |\n     *  'preferred-is-day-off'\n     * )} name \n     * @param {string | undefined} _oldValue \n     * @param {string | undefined} newValue \n     */\n    attributeChangedCallback(name, _oldValue, newValue) {\n        switch(name) {\n            case \"preferred-date\": {\n                this._value.date = newValue || '';\n            } break;\n            case \"preferred-time\": {\n                this._value.timeRange = timeRangeOf(newValue || '');\n                this._value.timeNumeric = timeNumericOf(newValue || '');\n            } break;\n            case \"preferred-description\": {\n                this._value.description = newValue || '';\n            } break;\n            case \"preferred-details\": {\n                this._value.details = newValue || '';\n            } break;\n            case \"preferred-is-day-off\": {\n                this._value.isDayOff = newValue === 'yes';\n            } break;\n        }\n\n        this.#rectifyAfterLoad();\n    }\n\n    #rectifyAfterLoad() {\n        const {\n            dateController,\n            timeRangeController,\n            timeNumericController,\n            isDayOffController,\n            descriptionController,\n            detailsController\n        } = this.#cache;\n        const value = this._value;\n\n        isDayOffController.checked = value.isDayOff;\n        isDayOffController.disabled = false;\n        \n        if(value.isDayOff) {\n            timeRangeController.value = 'fullday';\n            timeRangeController.disabled = true;\n\n            timeNumericController.value = '';\n            timeNumericController.disabled = true;\n        } else {\n            timeRangeController.value = value.timeRange;\n            timeRangeController.disabled = false;\n            if(!value.timeRange) {\n                timeNumericController.value = value.timeNumeric;\n                timeNumericController.disabled = false;\n                timeNumericController.required = true;\n            } else {\n                timeNumericController.value = '';\n                timeNumericController.disabled = true;\n                timeNumericController.required = false;\n            }\n        }\n\n        dateController.value = value.date;\n        dateController.disabled = false;\n\n        descriptionController.value = value.description;\n        descriptionController.disabled = false;\n\n        detailsController.value = value.details;\n        detailsController.disabled = false;\n    }\n\n    #rectifyAfterCancelStateChange() {\n        this.#rectifyAfterLoad();\n        if(this.#cache.cancelController.checked) {\n            const {\n                dateController,\n                timeRangeController,\n                timeNumericController,\n                isDayOffController,\n                descriptionController,\n                detailsController\n            } = this.#cache;\n\n            const controllersToFreeze = [\n                dateController,\n                timeNumericController,\n                timeRangeController,\n                isDayOffController,\n                descriptionController,\n                detailsController\n            ];\n\n            for(const controller of controllersToFreeze) {\n                controller.disabled = true;\n            }\n        }\n    }\n\n    #rectifyAfterChange() {\n        const {\n            timeRangeController,\n            timeNumericController,\n            isDayOffController\n        } = this.#cache;\n\n        // Time Range is frozen on fullday for days off\n        if(isDayOffController.checked) {\n            timeRangeController.value = 'fullday';\n            timeRangeController.disabled = true;\n        } else {\n            timeRangeController.disabled = false;\n        }\n\n        // Time Numeric is frozen when some time range\n        if(timeRangeController.value) {\n            timeNumericController.disabled = true;\n            timeNumericController.value = '';\n            timeNumericController.required = false;\n        } else {\n            timeNumericController.disabled = false;\n            timeNumericController.required = true;\n        }\n    }\n\n    #emitChange() {\n        const {\n            dateController,\n            timeRangeController,\n            timeNumericController,\n            isDayOffController,\n            descriptionController,\n            detailsController,\n            cancelController\n        } = this.#cache;\n\n        this.dispatchEvent(new CustomEvent(\n            \"app-calendar-mutation-form-change\",\n            {\n                detail: {\n                    date: dateController.value || undefined,\n                    time: (\n                        timeRangeController.value\n                            || timeNumericController.value || undefined\n                    ),\n                    description: descriptionController.value || undefined,\n                    details: detailsController.value || undefined,\n                    isDayOff: isDayOffController.checked,\n                    cancel: cancelController && cancelController.checked\n                }\n            }\n        ));\n    }\n\n    get #cache() {\n        if(!this._cache) {\n            const formController = (\n                /**\n                 * @type {HTMLFormElement}\n                 */ (\n                    this.querySelector(\"form\")\n                 )\n            );\n            this._cache = {\n                formController,\n                dateController: formController['dateController'],\n                timeRangeController: formController['timeRangeController'],\n                timeNumericController: formController['timeNumericController'],\n                isDayOffController: formController['isDayOffController'],\n                descriptionController: formController['descriptionController'],\n                detailsController: formController['detailsController'],\n                cancelController: formController['cancelController']\n            };\n        }\n        return this._cache;\n    }\n\n    /**\n     * @param {SubmitFormAction<{\n     *  cancel: true\n     * } | {\n     *  cancel: false,\n     *  isDayOff: boolean,\n     *  strDate: DateString,\n     *  strTime: TimeString,\n     *  strDescription: string,\n     *  strDetails: string | undefined\n     * }>} action \n     * @returns {Promise<unknown>}\n     */\n    submit = async action => {\n        const {\n            dateController,\n            timeRangeController,\n            timeNumericController,\n            descriptionController,\n            detailsController,\n            isDayOffController,\n            cancelController\n        } = this.#cache;\n\n        if(cancelController && cancelController.checked) {\n            await action({\n                cancel: true\n            });\n        } else {\n            await action({\n                cancel: false,\n                isDayOff: isDayOffController.checked,\n                strDate: dateController.value || undefined,\n                strTime: (\n                    timeRangeController.value ||\n                    timeNumericController.value || undefined\n                ),\n                strDescription: descriptionController.value || '',\n                strDetails: detailsController.value || undefined\n            });\n        }\n        return undefined;\n    };\n});\n\n\n//# sourceURL=webpack://v4/./src/js/components/forms/CalendarMutationForm.js?");

/***/ }),

/***/ "./src/js/date-utils.js":
/*!******************************!*\
  !*** ./src/js/date-utils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeGrid: () => (/* binding */ computeGrid),\n/* harmony export */   dateTimeToString: () => (/* binding */ dateTimeToString),\n/* harmony export */   dayOfDate: () => (/* binding */ dayOfDate),\n/* harmony export */   glueTemporalKey: () => (/* binding */ glueTemporalKey),\n/* harmony export */   mondayOfDateTime: () => (/* binding */ mondayOfDateTime),\n/* harmony export */   monthOfDate: () => (/* binding */ monthOfDate),\n/* harmony export */   nextDatetime: () => (/* binding */ nextDatetime),\n/* harmony export */   now: () => (/* binding */ now),\n/* harmony export */   strTimeOverlap: () => (/* binding */ strTimeOverlap),\n/* harmony export */   strTimeSorting: () => (/* binding */ strTimeSorting),\n/* harmony export */   stringToDateTime: () => (/* binding */ stringToDateTime),\n/* harmony export */   unglueTemporalKey: () => (/* binding */ unglueTemporalKey),\n/* harmony export */   validateDateString: () => (/* binding */ validateDateString),\n/* harmony export */   validateTimeString: () => (/* binding */ validateTimeString),\n/* harmony export */   yearOfDate: () => (/* binding */ yearOfDate)\n/* harmony export */ });\n/**\nAuthor: Justin DEKEYSER\nYear: August 2023\nLicense: All rights reserved\n\nUtility file to deal with dates and times.\n===============================================================================\n*/\n\n/**\n * @typedef {number & ((_0: undefined & null) => 'Timestamp')} Timestamp\n * @param {number} _ - Timestamp from Epoch\n * @returns {Timestamp}\n * ----------------------------------------------------------------------------\n */\nfunction castTimestamp(_) {\n    return (\n        /**\n         * @type {Timestamp}\n         */ (_)\n    );\n}\n\n/**\n * @param {string} _ - The input to cast as a string\n * @returns {DateString}\n * ----------------------------------------------------------------------------\n */\nfunction castDate(_) {\n    return (\n        /**\n         * @type {DateString}\n         */ (_)\n    );\n}\n\n/**\n * @param {string} _ - The input to cast as a string\n * @returns {TimeString}\n * ----------------------------------------------------------------------------\n */\nfunction castTime(_) {\n    return (\n        /**\n         * @type {TimeString}\n         */ (_)\n    );\n}\n\n/**\n * @param {string} _ - The input to cast as a string\n * @returns {TemporalKeyString}\n * ----------------------------------------------------------------------------\n */\nfunction castTemporalKeyString(_) {\n    return (\n        /**\n         * @type {TemporalKeyString}\n         */ (_)\n    );\n}\n\nconst YEAR_PATTERN = /^20[0-9][0-9]$/;\nconst MONTH_PATTERN = /^(0[1-9]|1[0-2])$/;\nconst DAY_PATTERN = /^([0-2][0-9]|3[0-1])$/;\nconst HOUR_PATTERN = /^([0-1][0-9]|2[0-4])$/;\nconst MINUTE_PATTERN = /^[0-5][0-9]$/;\n/**\n * @param {unknown} input - The expected date string\n * @returns {DateString | null} - As a date string, or nothing if invalid\n * ----------------------------------------------------------------------------\n */\nfunction validateDateString(input) {\n    valid: {\n        if(typeof input != \"string\") {\n            break valid;\n        }\n        const yearSegment = input.substring(0, 4);\n        const monthSegment = input.substring(5, 7);\n        const daySegment = input.substring(8, 10);\n\n        if(!yearSegment.match(YEAR_PATTERN)) {\n            break valid;\n        }\n        if(!monthSegment.match(MONTH_PATTERN)) {\n            break valid;\n        }\n        if(!daySegment.match(DAY_PATTERN)) {\n            break valid;\n        } else if(daySegment == \"31\") {\n            switch(monthSegment) {\n                case \"02\":\n                case \"04\":\n                case \"06\":\n                case \"09\":\n                case \"11\":\n                    break valid;\n            }\n        } else if (daySegment >= \"29\" && monthSegment == \"02\") {\n            break valid;\n        } else if (daySegment == \"29\" && monthSegment == \"02\") {\n            /* Leap years are divisible by 400, or else by 4 but not by 100\n                We know the YEAR_PATTERN only allows dates before 2100,\n                strictly. So we only have to take into account divisers of 4\n                in [2000,2100), which we trivially do with a switch on the\n                last two digits, cause the pattern repeats\n            */\n            leapCheck: {\n                switch(yearSegment[2]) {\n                case \"0\":\n                case \"2\":\n                case \"4\":\n                case \"6\":\n                case \"8\":\n                    switch(yearSegment[3]) {\n                        case \"0\":\n                        case \"4\":\n                        case \"8\":\n                            break leapCheck;\n                        default:\n                            break valid;\n                    }\n                default:\n                    switch(yearSegment[3]) {\n                        case \"2\":\n                        case \"6\":\n                            break leapCheck;\n                        default:\n                            break valid;\n                    }\n                }\n            }\n        }\n        return castDate([yearSegment, monthSegment, daySegment].join('-'));\n    }\n    return null;\n}\n\n/**\n * @param {unknown} input - The expected time string\n * @returns {TimeString | null} - As a time string, or nothing if invalid\n * ----------------------------------------------------------------------------\n */\nfunction validateTimeString(input) {\n    valid: {\n        if(typeof input != \"string\") {\n            break valid;\n        }\n        switch(input) {\n            case \"fullday\":\n            case \"morning\":\n            case \"afternoon\":\n                return castTime(input);\n            default: {\n                const hourSegment = input.substring(0, 2);\n                const minuteSegment = input.substring(3, 5);\n            \n                if(!hourSegment.match(HOUR_PATTERN)) {\n                    break valid;\n                }\n                if(!minuteSegment.match(MINUTE_PATTERN)) {\n                    break valid;\n                }\n                return castTime([hourSegment, minuteSegment].join(':'));\n            }\n        }\n    }\n    return null;\n}\n\n/**\n * \n * @param {TemporalKey} temporalKey - The temporal key, unglued\n * @returns {TemporalKeyString} - The temporal key string\n * ----------------------------------------------------------------------------\n */\nfunction glueTemporalKey(temporalKey) {\n    const { date, time } = temporalKey;\n    return castTemporalKeyString(`${date} ${time}`);\n}\n\n/**\n * @param {TemporalKeyString} temporaleyString - the temporal key as a string\n * @returns {TemporalKey} - The unglued key\n * ----------------------------------------------------------------------------\n */\nfunction unglueTemporalKey(temporaleyString) {\n    const strDate = temporaleyString.substring(\n        0, temporaleyString.indexOf(\" \")\n    );\n    const strTime = temporaleyString.substring(strDate.length + 1);\n\n    const date = validateDateString(strDate);\n    const time = validateTimeString(strTime);\n    return (\n        /**\n         * @type {TemporalKey}\n         */\n        ({ date, time })\n    );\n}\n\n/**\n * Gets the current date, as a string. This is wrapped for coherency reasons.\n * \n * @returns {DateString} - The date, as a string\n * ----------------------------------------------------------------------------\n */\nfunction now()\n{\n    // Check MDN: Date.now returns a timestamp from epoch.\n    // Date constructor from number will agree on this convention.\n    // This means that for a belgian user, the iso string might not correspond\n    // to today date (because of timezone). We thus extract a local string\n    // and recreate the correct datestring.\n    const nowDate = new Date(Date.now());\n    const localString = nowDate.toLocaleDateString(\"fr-BE\");\n    const [day, month, year] = localString.split(\"/\");\n    return castDate([year, month, day].join('-'));\n}\n\n/**\n * Computes the UTC day of week corresponding to a timestamp from Epoch.\n * This computation is meant for module private usages.\n * \n * @param {Timestamp} datetime - The datetime, as a timestamp from Epoch\n * @returns {number} - The UTC day of week\n * ----------------------------------------------------------------------------\n */\nfunction __dayOfWeek(datetime)\n{\n    return new Date(datetime).getUTCDay();\n}\n\n/**\n * Returns a string representation of the date corresponding to the provided\n * timestamp. Information about time (hours, minutes, ...) are forgotten by\n * this process.\n * \n * @param {Timestamp} datetime - As a timestamp from Epoch\n * @returns {DateString} - The date, as a YYYY-MM-DD\n * ----------------------------------------------------------------------------\n */\nfunction dateTimeToString(datetime)\n{\n    // Compared to `now`, the current method is not supposed to use locals.\n    // It uses UTC conventions, as it is meant to be used through computations\n    // on timestamp. We cannot reason in timestamps with locals.\n    const EXPECTED_LENGTH = \"YYYY-MM-DD\".length;\n    const isoString = new Date(datetime).toISOString();\n\n    return castDate(isoString.substring(0, EXPECTED_LENGTH));\n}\n\n/**\n * Parse a given string that must follow the format YYYY-MM-DD, and returns\n * a timestamp from Epoch that corresponds to that string (itself interpreted\n * as a date in UTC). The method does not validate the input.\n * \n * This method is the converse of `datetimeToString`.\n * \n * @param {DateString} strDate - A date, as a string \n * @returns {Timestamp} - The date, as a timestamp from Epoch\n * ----------------------------------------------------------------------------\n */\nfunction stringToDateTime(strDate)\n{\n    // Checkout MDN: Web/JavaScript/Reference/Global_Objects/Date/parse\n    // The parse method with a day YYYY-MM-DD is understood in UTC.\n    return castTimestamp(Date.parse(strDate));\n}\n\n/**\n * Iterates on a datetime (as a timestamp from Epoch) to get the next one,\n * with a day (24 hours) based step.\n * \n * This methods accepts options to specify the day and week shifts. They\n * might be null or negative. If unspecified or both null, they are\n * interpreted as a shift of 1 day forward.\n * \n * Example:\n *  - Shifting by one day forward might be done using\n *      `nextDatetime(d, { dayShift: 1 })`\n *    or equivalently\n *      `nextDatetime(d)`\n * \n *  - Shifting by two weeks backward might be done with\n *      `nextDatetime(d, { weekShift: -2 })\n * \n * @param {Timestamp} datetime - The reference timestamp from Epoch\n * @param {{dayShift?: number, weekShift?: number}} [options] - Options\n * @returns {Timestamp} - A timestamp whose day of week comes next\n * ----------------------------------------------------------------------------\n */\nfunction nextDatetime(datetime, options)\n{\n    if(!options) {\n        return nextDatetime(datetime, {});\n    } else {\n        const { dayShift, weekShift } = options;\n        if(weekShift || !dayShift) {\n            const effectiveDayShift = {\n                dayShift: weekShift ? (weekShift*7 + (dayShift || 0)) : 1\n            };\n            return nextDatetime(datetime, effectiveDayShift);\n        } else {\n            const DAY_SHIFT = 1000*60*60*24;\n            return castTimestamp(datetime + dayShift * DAY_SHIFT);\n        }\n    }\n}\n\n/**\n * Computes a timestamp from Epoch, whose UTC day of week is guaranteed to be\n * the first Monday preceding the provided reference. If the reference is\n * already a Monday, the same reference is returned.\n * \n * @param {Timestamp} datetime - The reference timestamp from Epoch\n * @returns {Timestamp} - The first Monday before, as a timestamp from Epoch \n * ----------------------------------------------------------------------------\n */\nfunction mondayOfDateTime(datetime)\n{\n    const dayOfWeek = __dayOfWeek(datetime);\n    const dayShift = - ((dayOfWeek + 6) % 7);\n\n    return dayShift ? nextDatetime(datetime, { dayShift }) : datetime;\n}\n\n/**\n * Given a date string in YYYY-MM-DD format, returns the DD segment.\n * \n * @typedef {(\n *  '01'|'02'|'03'|'04'|'05'|'06'|'07'|'08'|'09'|'10'|\n*   '11'|'12'|'13'|'14'|'15'|'16'|'17'|'18'|'19'|'20'|\n*   '21'|'22'|'23'|'24'|'25'|'26'|'27'|'28'|'29'|'30'|'31'\n * )} DayPart\n * \n * @param {DateString} strDate - The date string\n * @returns {DayPart} - The day part\n * ----------------------------------------------------------------------------\n */\nfunction dayOfDate(strDate)\n{\n    const dayPart = (\n        /**\n         * @type {DayPart}\n         */ (strDate.substring(8, 10))\n    );\n    return dayPart;\n}\n\n/**\n * Given a date string in YYYY-MM-DD format, returns the MM segment.\n * \n * @typedef {(\n*  '01'|'02'|'03'|'04'|'05'|'06'|'07'|'08'|'09'|'10'|'11'|'12'\n* )} MonthPart\n * \n * @param {DateString} strDate - The date string\n * @returns {MonthPart} - The month part\n * ----------------------------------------------------------------------------\n */\nfunction monthOfDate(strDate)\n{\n    const monthPart = (\n        /**\n         * @type {MonthPart}\n         */ (strDate.substring(5, 7))\n    );\n    return monthPart;\n}\n\n/**\n * Given a date string in YYYY-MM-DD format, returns the YYYY segment.\n * \n * @param {DateString} strDate - The date string\n * @returns {string} - The year part\n * ----------------------------------------------------------------------------\n */\nfunction yearOfDate(strDate)\n{\n    return strDate.substring(0, 4);\n}\n\n\n/**\n * Converts the time, as a rich entity, to a token that can be used for easy\n * sorting by lexicographic ordering, preserving the equivalence between\n * lexicographic sort and chronological sort.\n * \n * @param {TimeString} strTime - The time to convert for easy sorting\n * @returns An alternative representation of the time\n * ----------------------------------------------------------------------------\n */\nfunction strTimeSortConverter(strTime)\n{\n    switch(strTime) {\n        case \"fullday\": return \"\";\n        case \"afternoon\": return \"12\";\n        case \"morning\": return \"00\";\n        default: return strTime;\n    }\n}\n\n/**\n * Compares two time-strings. This method is a comparator function, and\n * follows the usual related protocol. In particular, the method is\n * skew-symmetric, transitive, and reflexive.\n * \n * Supported time string are of the kind HH:MM but can also be one\n * of \"afternoon\", \"morning\" or \"fullday\". The \"fullday\" always comes first,\n * while lexical tokens \"morning\" and \"afternoon\" always comes before the\n * times that occur during them.\n * \n * Example:\n *  - 13:00 is bigger than afternoon\n *  - 10:56 is bigger than morning, but smaller than afternoon\n *  - 00:00 is strictly bigger than morning\n * \n * @param {TimeString} a - The first time, as a TimeString\n * @param {TimeString} b - The second time, as a TimeString \n * @returns {-1 | 1 | 0} - The result of the comparison\n * ----------------------------------------------------------------------------\n */\nfunction strTimeSorting(a, b)\n{\n    if(a == b) {\n        return 0;\n    } else {\n        return strTimeSortConverter(a) <= strTimeSortConverter(b) ? -1 : 1;\n    }\n}\n\n/**\n * Computes if two times (as string, in the general sense) overlap each\n * others.\n * \n * Example:\n *  - \"afternoon\" and 14:39, overlap each others.\n * \n * @param {TimeString} a - The first time-string\n * @param {TimeString} b - The second time-string\n * @returns {boolean} whether or not the time overlap each others\n * ----------------------------------------------------------------------------\n */\nfunction strTimeOverlap(a, b)\n{\n    const overlap = (\n           a == b\n        || a == \"fullday\"\n        || b == \"fullday\"\n        || (a == \"afternoon\" && b >= \"12:00\" && b != \"morning\")\n        || (b == \"afternoon\" && a >= \"12:00\" && b != \"morning\")\n        || (a == \"morning\" &&  b < \"12:00\")\n        || (b == \"morning\" && a < \"12:00\")\n    );\n    return overlap;\n}\n\n/**\n * Generate a grid table, given a specified number of weeks.\n * Every block corresponds to weeks of a month, and contains\n * weeks to display. Every week is made of seven entries,\n * that might be undefined (in case the week does not fully\n * cover a month)\n * \n * @param {DateString} focusDate\n * @param {number} numberOfWeeks\n * @param {boolean} coverLastMonthEntirely\n * @returns {Array.<Array.<Array.<DateString | undefined>>>}\n * ----------------------------------------------------------------------------\n */\nfunction computeGrid(focusDate, numberOfWeeks, coverLastMonthEntirely) {\n    const focusDatetime = stringToDateTime(focusDate);\n\n    /**\n     * @type {Array.<DateString>}\n     */\n    const dates = [];\n\n    // Hard filling the dates with the correct amount of days.\n    {\n        const numberOfDays = numberOfWeeks * 7;\n\n        let cursor = mondayOfDateTime(focusDatetime);\n        for(let i = 0; i < numberOfDays; i++) {\n            dates.push(dateTimeToString(cursor));\n            cursor = nextDatetime(cursor);\n        }\n\n        if(coverLastMonthEntirely) {\n            const lastMonthInserted = monthOfDate(dates[dates.length - 1]);\n            for(;;) {\n                const date = dateTimeToString(cursor);\n                if(monthOfDate(date) == lastMonthInserted) {\n                    dates.push(date);\n                    cursor = nextDatetime(cursor);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @type {Array.<DateString | undefined>}\n     */\n    const rectifiedDates = [];\n\n    {\n        let currentMonth = monthOfDate(focusDate);\n        for(let i = 0; i < dates.length; i++) {\n            const date = dates[i];\n\n            if(date < focusDate) {\n                if(monthOfDate(date) != currentMonth) {\n                    rectifiedDates.push(undefined);\n                } else {\n                    rectifiedDates.push(date);\n                }\n            } else {\n                const dateMonth = monthOfDate(date);\n                if(currentMonth !== dateMonth && (i % 7)) {\n                    // Month shift, not a Monday. Need to insert 7 cells first\n                    for(let j = 0; j < 7; j++) {\n                        rectifiedDates.push(undefined);\n                    }\n                }\n                currentMonth = dateMonth;\n                rectifiedDates.push(date);\n            }\n        }\n\n        while(rectifiedDates.length % 7) {\n            rectifiedDates.push(undefined);\n        }\n    }\n\n    // Group by seven!\n    // A group starts when the week starts with undefined or 01\n\n    /**\n     * @type {Array.<Array.<Array.<DateString | undefined>>>}\n     */\n    const blocks = [];\n    for(let i = 0; i < rectifiedDates.length;) {\n        const date = rectifiedDates[i];\n        if(i == 0 || !date || dayOfDate(date) === \"01\") {\n            blocks.push([]);\n        }\n        const lastBlock = blocks[blocks.length - 1];\n        lastBlock.push(rectifiedDates.slice(i, i += 7));\n    }\n\n    return blocks;\n}\n\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/date-utils.js?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _backend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend.js */ \"./src/js/backend.js\");\n/* harmony import */ var _template_engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template-engine.js */ \"./src/js/template-engine.js\");\n/* harmony import */ var _components_LongFrenchDate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/LongFrenchDate.js */ \"./src/js/components/LongFrenchDate.js\");\n/* harmony import */ var _components_LongFrenchTime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/LongFrenchTime.js */ \"./src/js/components/LongFrenchTime.js\");\n/* harmony import */ var _components_FrenchMonth_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/FrenchMonth.js */ \"./src/js/components/FrenchMonth.js\");\n/* harmony import */ var _components_DayTwoDigits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/DayTwoDigits.js */ \"./src/js/components/DayTwoDigits.js\");\n/* harmony import */ var _components_MonthTwoDigits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/MonthTwoDigits.js */ \"./src/js/components/MonthTwoDigits.js\");\n/* harmony import */ var _components_YearFourDigits_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/YearFourDigits.js */ \"./src/js/components/YearFourDigits.js\");\n/* harmony import */ var _components_forms_AuthenticationForm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/forms/AuthenticationForm.js */ \"./src/js/components/forms/AuthenticationForm.js\");\n/* harmony import */ var _components_forms_AuthenticationForm_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_components_forms_AuthenticationForm_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _components_forms_CalendarMutationForm_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/forms/CalendarMutationForm.js */ \"./src/js/components/forms/CalendarMutationForm.js\");\n/* harmony import */ var _components_forms_CalendarMutationForm_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_components_forms_CalendarMutationForm_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _pages_CalendarGridStrategy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pages/CalendarGridStrategy.js */ \"./src/js/pages/CalendarGridStrategy.js\");\n/* harmony import */ var _pages_appointment_list_AppointmentDayList_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pages/appointment-list/AppointmentDayList.js */ \"./src/js/pages/appointment-list/AppointmentDayList.js\");\n/* harmony import */ var _pages_appointment_list_UnreadAppointmentList_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pages/appointment-list/UnreadAppointmentList.js */ \"./src/js/pages/appointment-list/UnreadAppointmentList.js\");\n/* harmony import */ var _pages_appointment_list_AppointmentSearchList_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pages/appointment-list/AppointmentSearchList.js */ \"./src/js/pages/appointment-list/AppointmentSearchList.js\");\n/* harmony import */ var _pages_CalendarMutationPage_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pages/CalendarMutationPage.js */ \"./src/js/pages/CalendarMutationPage.js\");\n/* harmony import */ var _pages_AuthenticationPage_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./pages/AuthenticationPage.js */ \"./src/js/pages/AuthenticationPage.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * ----------------------------------------------------------------------------\n */\n\nfunction getAnchorElement() {\n    return document.getElementById(\"anchor-content\");\n}\n\n\n/**\n * ----------------------------------------------------------------------------\n */\n\nconst DISALLOW_RELOAD_ON_403 = 'disallow403Reload';\n\n/**\n * ----------------------------------------------------------------------------\n */\n\n\ncustomElements.define(\"app-route-listener\", class extends HTMLElement {\n    constructor() {\n        super();\n        this.currentRouteURL = undefined;\n    }\n    \n    connectedCallback() {\n        window.addEventListener(\"popstate\",\n            e => this.#handleHistoryChange({ state: e.state })\n        );\n        window.addEventListener(\"app-navigate\",\n            ({ detail }) => this.#handleNavigation(detail)\n        );\n\n        (async () => {\n            await READY;\n            this.__URLS = new Map([\n                ['/calendar-grid/', new _pages_CalendarGridStrategy_js__WEBPACK_IMPORTED_MODULE_10__.CalendarGridStartegy()],\n                ['/appointments/day/', new _pages_appointment_list_AppointmentDayList_js__WEBPACK_IMPORTED_MODULE_11__.AppointmentDayList()],\n                ['/appointments/unread/', new _pages_appointment_list_UnreadAppointmentList_js__WEBPACK_IMPORTED_MODULE_12__.UnreadAppointmentList()],\n                ['/appointments/search/', new _pages_appointment_list_AppointmentSearchList_js__WEBPACK_IMPORTED_MODULE_13__.AppointmentSearchList()],\n                ['/calendar/mutate/create', new _pages_CalendarMutationPage_js__WEBPACK_IMPORTED_MODULE_14__.CalendarMutationCreatePage()],\n                ['/calendar/mutate/modify', new _pages_CalendarMutationPage_js__WEBPACK_IMPORTED_MODULE_14__.CalendarMutationModifyPage()],\n                ['/authentication/', new _pages_AuthenticationPage_js__WEBPACK_IMPORTED_MODULE_15__.AuthenticationPage()]\n            ]);\n\n            this.#handleHistoryChange({});\n        })();\n    }\n    \n    #handleHistoryChange({ state, hash }) {\n        if(state) {\n            this.#handleNavigation(state);\n        } else if(hash == null) {\n            let nextHash;\n            try {\n                nextHash = atob(location.hash.substring(1));\n            } catch(error) {\n                nextHash = '';\n            }\n            return this.#handleHistoryChange({ hash: nextHash });\n        } else {\n            let url = hash.substring(0, hash.indexOf('?'));\n            let queryParser = new URLSearchParams(\n                hash.substring(url.length+1, hash.length)\n                );\n            let parameters = Object.fromEntries(queryParser);\n            this.#handleHistoryChange({ state: { url, parameters } });\n        }\n    }\n\n    #handleNavigation({ url, parameters }) {\n        navigate: {\n            onResolvedUrl: {\n                if(!url) {\n                    break onResolvedUrl;\n                } else {\n                    const strategy = this.__URLS.get(url);\n                    if(!strategy) {\n                        break onResolvedUrl;\n                    } else {\n                        this.currentRouteURL = url;\n                        getAnchorElement().innerHTML = \"\";\n                        (\n                            url == '/authentication/'\n                                ? this.#patchAuthenticationPrototype(strategy)\n                                : this.#patchPrototype(strategy)\n                        ).paint(parameters).catch(console.error\n                            /* We silent the error here,\n                            because likely it is a auth error\n                            and the recovery is performed by a decorator */\n                        );\n                        break navigate;\n                    }\n                }\n            }\n            // If we are here, resolution failed. fallback\n            this.#emitNavigation({\n                url: '/calendar-grid/',\n                parameters: {}\n            });\n        }\n    }\n\n    #emitNavigation({ url, parameters }) {\n        dispatchEvent(new CustomEvent(\n            \"app-navigate\",\n            { detail : { url, parameters } }\n        ));\n    }\n\n    #handleAuthenticationError(anyAction) {\n        return (async function() {\n            try {\n                const result = await anyAction(...arguments);\n                window.sessionStorage.removeItem(DISALLOW_RELOAD_ON_403);\n                return result;\n            } catch(error) {\n                let { errorCode, errorMessage } = error;\n                if(\n                    errorCode == 403 &&\n                    !window.sessionStorage.getItem(DISALLOW_RELOAD_ON_403)\n                ) {\n                    window.sessionStorage.setItem(DISALLOW_RELOAD_ON_403, true);\n                    window.location.reload();\n                }\n                if([401,403,429].includes(errorCode)) {\n                    this.#emitNavigation({\n                        url: '/authentication/',\n                        parameters: {\n                            errorMessage\n                        }\n                    });\n                }\n                throw error;\n            }\n        }).bind(this);\n    }\n\n    #patchPrototype(strategy) {\n        const basePage = this.#patchBasePagePrototype(strategy);\n        const self = this;\n        const _backendAdapter = {\n            get state() {\n                return self.#handleAuthenticationError(\n                    () => _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.state\n                )();\n            },\n        \n            get authentify() {\n                return self.#handleAuthenticationError(\n                    _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.authentify\n                );\n            },\n        \n            get createEvent() {\n                return self.#handleAuthenticationError(\n                    _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.createEvent\n                );\n            },\n            \n            get cancelEvent() {\n                return self.#handleAuthenticationError(\n                    _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.cancelEvent\n                );\n            },\n            \n            get editEvent() {\n                return self.#handleAuthenticationError(\n                    _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.editEvent\n                );\n            },\n            \n            get markRead() {\n                return self.#handleAuthenticationError(\n                    _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.markRead\n                );\n            }\n        };\n        Object.setPrototypeOf(_backendAdapter, basePage);\n        return _backendAdapter;\n    }\n\n    #patchAuthenticationPrototype(strategy) {\n        const basePage = this.#patchBasePagePrototype(strategy);\n        const _backendAdapter = {\n            get state() {\n                throw \"Property not available in Authentication process\";\n            },\n        \n            get authentify() {\n                return _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.authentify;\n            },\n\n            get authentifiedUser() {\n                return _backend_js__WEBPACK_IMPORTED_MODULE_0__.backend.authentifiedUser;\n            },\n        \n            get createEvent() {\n                throw \"Property not available in Authentication process\";\n            },\n            \n            get cancelEvent() {\n                throw \"Property not available in Authentication process\";\n            },\n            \n            get editEvent() {\n                throw \"Property not available in Authentication process\";\n            },\n            \n            get markRead() {\n                throw \"Property not available in Authentication process\";\n            }\n        };\n        Object.setPrototypeOf(_backendAdapter, basePage);\n        return _backendAdapter;\n    }\n\n    #patchBasePagePrototype(strategy) {\n        const self = this;\n        const pagePrototype = {\n            navigateTo: function({ url, parameters }) {\n                const currentState = history.state;\n                {\n                    const sp = new URLSearchParams();\n                    for(const [key, value] of Object.entries(parameters)) {\n                        sp.append(key, value);\n                    }\n                    const queryString = `${url}?${sp.toString()}`;\n                    const hash = `#${btoa(queryString)}`;\n                    const state = { url, parameters };\n\n                    if(currentState && currentState.url === state.url) {\n                        history.replaceState(state, '', hash);\n                    } else {\n                        history.pushState(state, '', hash);\n                    }\n                }\n                return self.#emitNavigation({url, parameters });\n            },\n\n            get anchorElement() {\n                return getAnchorElement();\n            },\n\n            getTemplate: function(templateId) {\n                return (0,_template_engine_js__WEBPACK_IMPORTED_MODULE_1__.getTemplate)(templateId);\n            }\n        };\n        Object.setPrototypeOf(pagePrototype, strategy);\n        return pagePrototype;\n    }\n    \n});\n\nconst READY = new Promise(res => {\n    window.addEventListener(\"load\", res);\n});\n\n\n//# sourceURL=webpack://v4/./src/js/main.js?");

/***/ }),

/***/ "./src/js/pages/AuthenticationPage.js":
/*!********************************************!*\
  !*** ./src/js/pages/AuthenticationPage.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticationPage: () => (/* binding */ AuthenticationPage),\n/* harmony export */   paintAuthenticationPage: () => (/* binding */ paintAuthenticationPage)\n/* harmony export */ });\nconst TEMPLATE_ID = \"authentication-pane\";\n\n/**\n * @this {AppPage}\n * @param {CredentialsInput} credentials\n * @returns {Promise<unknown>}\n */\nasync function onFormSubmit(credentials) {\n    await this.authentify(credentials);\n    this.navigateTo({\n        url: '/calendar-grid',\n        parameters: {}\n    });\n    return undefined;\n}\n\n/**\n * @this {AppPage}\n * @returns {Promise<unknown>}\n */\nasync function paintAuthenticationPage() {\n    this.anchorElement.setAttribute(\"data-id\", TEMPLATE_ID);\n\n    /**\n     * @param {AppEvent.<ActionRunner.<CredentialsInput>>} _\n     */\n    const handleAppAuthentify = ({ detail }) => void detail(onFormSubmit.bind(this));\n\n    this.getTemplate(TEMPLATE_ID)(\n        this.anchorElement,\n        {\n            username: this.authentifiedUser.userName,\n            handleAppAuthentify\n        },\n        \"0\"\n    );\n\n    return undefined;\n}\n\n\nfunction AuthenticationPage() {}\nAuthenticationPage.prototype = {\n    paint: paintAuthenticationPage\n};\n\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/AuthenticationPage.js?");

/***/ }),

/***/ "./src/js/pages/CalendarGridStrategy.js":
/*!**********************************************!*\
  !*** ./src/js/pages/CalendarGridStrategy.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarGridStartegy: () => (/* binding */ CalendarGridStartegy)\n/* harmony export */ });\n/* harmony import */ var _date_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils.js */ \"./src/js/date-utils.js\");\n\n\n/**\n * @typedef {{\n *  strDate: DateString,\n *  hasAppointments: boolean,\n *  hasNoUnread: boolean,\n *  inFocusMonth: boolean,\n *  isToday: boolean,\n *  isFocus: boolean,\n *  isDayOff: boolean,\n *  handleClick: *\n * }} FilledTemplateGridCellData\n *\n * @typedef {{\n *  strDate: undefined,\n *  hasAppointments: false,\n *  hasNoUnread: true,\n *  inFocusMonth: true,\n *  isToday: false,\n *  isFocus: false,\n *  isDayOff: false,\n *  handleClick: undefined\n * }} UnfilledTemplateGridCellData\n * \n * @typedef {UnfilledTemplateGridCellData |\n *           FilledTemplateGridCellData} TemplateGridCellData\n */\n\n\n/**\n * \n * @param {{\n *  strDate: DateString | undefined,\n *  todayStrDate: DateString,\n *  focusStrDate: DateString\n * }} dateData \n * @param {View} view \n * @param {NavigateToCallback} navigateTo \n * @returns {TemplateGridCellData}\n */\nfunction makeCell(dateData, view, navigateTo) {\n    const { strDate, todayStrDate, focusStrDate } = dateData;\n    if(!strDate) {\n        return {\n            strDate: undefined,\n            hasAppointments: false,\n            hasNoUnread: true,\n            inFocusMonth: true,\n            isToday: false,\n            isFocus: false,\n            isDayOff: false,\n            handleClick: undefined\n        };\n    } else {\n        const timeMap = new Map(view.get(strDate));\n    \n        let hasUnread = false;\n        let hasAppointments = false;\n        let anyDayOff = false;\n        for (const { unread, isDayOff } of timeMap.values()) {\n            hasAppointments = true;\n            hasUnread = hasUnread || unread;\n            anyDayOff = anyDayOff || isDayOff;\n        }\n    \n        return {\n            strDate,\n            hasAppointments,\n            hasNoUnread: !hasUnread,\n            inFocusMonth: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.monthOfDate)(strDate) == (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.monthOfDate)(focusStrDate),\n            isToday: strDate == todayStrDate,\n            isFocus: strDate == focusStrDate,\n            isDayOff: anyDayOff,\n            handleClick: () => void navigateTo({\n                url: '/appointments/day/',\n                parameters: {\n                    strDate\n                }\n            })\n        };\n    }\n}\n\n/**\n * \n * @param {{\n *  numberOfWeeks: number,\n *  todayStrDate: DateString,\n *  focusStrDate: DateString\n * }} tableData \n * @param {View} view \n * @param {NavigateToCallback} navigateTo \n * @returns {{\n *  blocks: Array.<{\n *      rows: Array.<{\n *          cols: Array.<TemplateGridCellData>\n *      }>,\n *      strDate: DateString | undefined\n *  }>\n * }}\n */\nfunction generateTable(tableData, view, navigateTo) {\n    const { numberOfWeeks, todayStrDate, focusStrDate } = tableData;\n\n    const blocks = (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.computeGrid)(\n        focusStrDate, Math.min(5, numberOfWeeks), numberOfWeeks == 6\n    );\n\n    return {\n        blocks: blocks.map(block => ({\n            rows: block.map(week => ({\n                cols: week.map(strDate => makeCell({\n                    strDate, todayStrDate, focusStrDate\n                }, view, navigateTo))\n            })),\n            strDate: block[0].find(Boolean)\n        }))\n    };\n}\n\nfunction makeNumberOfWeeksCtrl(\n    { numberOfWeeks, firstWeekIncludes },\n    navigateTo\n) {\n    return {\n        handleChange: event => {\n            navigateTo({\n                url: '/calendar-grid/',\n                parameters: {\n                    firstWeekIncludes,\n                    numberOfWeeks: event.target.value\n                }\n            });\n        },\n        value: numberOfWeeks\n    };\n}\n\nfunction makeFirstDateIncludesCtrl(\n    { dateTime, numberOfWeeks },\n    navigateTo\n) {\n    return {\n        handleChange: event => {\n            if (!event.target.value) { return; }\n\n            navigateTo({\n                url: '/calendar-grid/',\n                parameters: {\n                    firstWeekIncludes: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeToString)(event.target.value),\n                    numberOfWeeks\n                }\n            });\n        },\n        value: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeToString)(dateTime)\n    };\n}\n\nfunction makeNextWeekCtrl({ dateTime, numberOfWeeks }, navigateTo) {\n    return {\n        handleClick: () => {\n            navigateTo({\n                url: '/calendar-grid/',\n                parameters: {\n                    firstWeekIncludes: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeToString)(\n                        (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextDatetime)(dateTime, { weekShift: 1 })\n                    ),\n                    numberOfWeeks\n                }\n            });\n        }\n    };\n}\n\nfunction makePreviousWeekCtrl({ dateTime, numberOfWeeks }, navigateTo) {\n    return {\n        handleClick: () => {\n            navigateTo({\n                url: '/calendar-grid/',\n                parameters: {\n                    firstWeekIncludes: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeToString)(\n                        (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.nextDatetime)(dateTime, { weekShift: -1 })\n                    ),\n                    numberOfWeeks\n                }\n            });\n        }\n    };\n}\n\nfunction makeUnreadNavigation({ newEvents }, navigateTo) {\n    if (newEvents.length) {\n        return {\n            size: newEvents.length,\n            handleClick: () => {\n                navigateTo({\n                    url: '/appointments/unread/',\n                    parameters: {}\n                });\n            }\n        };\n    }\n}\n\nfunction makeSearchNavigation(navigateTo) {\n    return {\n        handleClick: () => {\n            navigateTo({\n                url: '/appointments/search/',\n                parameters: {}\n            });\n        }\n    };\n}\n\n\nconst GRID_MAIN_ID = \"calendar-grid_main\";\nconst GRID_ROWS_ID = \"calendar-grid_rows\";\n\nfunction CalendarGridStartegy() {}\nCalendarGridStartegy.prototype = {\n    get _environment() {\n        return (\n            /**\n             * @type {PageEnvironmentConfig}\n             */ (\n                /**\n                 * @type {unknown}\n                 */ (this)\n            )\n        );\n    },\n\n    /**\n     * @param {{\n     *  numberOfWeeks: number | undefined,\n     *  firstWeekIncludes: DateString | undefined\n     * }} parameters \n     * @returns {Promise<unknown>}\n     */\n    paint: async function(parameters) {\n        const { numberOfWeeks, firstWeekIncludes } = parameters;\n        if (!numberOfWeeks) {\n            const fromStore = sessionStorage.getItem('numberOfWeeks');\n            if(fromStore) {\n                const numberFromStore = parseInt(fromStore);\n                if(isFinite(numberFromStore)) {\n                    return await this.paint({\n                        numberOfWeeks: numberFromStore,\n                        firstWeekIncludes\n                    });\n                }\n            }\n            return await this.paint({\n                numberOfWeeks: 5,\n                firstWeekIncludes\n            });\n        } else {\n            sessionStorage.setItem('numberOfWeeks', String(numberOfWeeks));\n        }\n        if (!firstWeekIncludes) {\n            const fromStore = sessionStorage.getItem('firstWeekIncludes');\n            if(fromStore) {\n                const dateFromStore = (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateDateString)(fromStore);\n                if(dateFromStore) {\n                    return await this.paint({\n                        numberOfWeeks,\n                        firstWeekIncludes: dateFromStore\n                    });\n                }\n            }\n            return await this.paint({\n                numberOfWeeks,\n                firstWeekIncludes: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)()\n            });\n        } else {\n            sessionStorage.setItem('firstWeekIncludes', firstWeekIncludes);\n        }\n\n        const { view, newEvents } = await this.state;\n        this.anchorElement.setAttribute(\"data-id\", GRID_MAIN_ID);\n\n        const firstWeekIncludes_dateTime = (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToDateTime)(\n            firstWeekIncludes\n        );\n        const todayStrDate = (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)();\n\n        this.getTemplate(GRID_MAIN_ID)(\n            this.anchorElement,\n            {\n                numberOfWeeksController: makeNumberOfWeeksCtrl({\n                    numberOfWeeks,\n                    firstWeekIncludes\n                }, this.navigateTo),\n                firstDateIncludesController: makeFirstDateIncludesCtrl({\n                    dateTime: firstWeekIncludes_dateTime,\n                    numberOfWeeks\n                }, this.navigateTo),\n                previousWeekController: makePreviousWeekCtrl({\n                    dateTime: firstWeekIncludes_dateTime,\n                    numberOfWeeks\n                }, this.navigateTo),\n                nextWeekController: makeNextWeekCtrl({\n                    dateTime: firstWeekIncludes_dateTime,\n                    numberOfWeeks\n                }, this.navigateTo),\n                unreadNavigation: makeUnreadNavigation(\n                    { newEvents }, this.navigateTo\n                ),\n                searchNavigation: makeSearchNavigation(this.navigateTo)\n            },\n            \"0\"\n        );\n\n        this.getTemplate(GRID_ROWS_ID)(\n            this.anchorElement.querySelector(`*[data-id=${GRID_ROWS_ID}]`),\n            generateTable({\n                numberOfWeeks, todayStrDate,\n                focusStrDate: firstWeekIncludes\n            }, view, this.navigateTo),\n            \"1\"\n        );\n\n        return undefined;\n    }\n};\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/CalendarGridStrategy.js?");

/***/ }),

/***/ "./src/js/pages/CalendarMutationPage.js":
/*!**********************************************!*\
  !*** ./src/js/pages/CalendarMutationPage.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarMutationCreatePage: () => (/* binding */ CalendarMutationCreatePage),\n/* harmony export */   CalendarMutationModifyPage: () => (/* binding */ CalendarMutationModifyPage)\n/* harmony export */ });\n/* harmony import */ var _date_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../date-utils.js */ \"./src/js/date-utils.js\");\n/* harmony import */ var _components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/appointments-list/AbstractAppointmentsList.js */ \"./src/js/components/appointments-list/AbstractAppointmentsList.js\");\n/* harmony import */ var _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algebra/MonadicIteratorMap.js */ \"./src/js/algebra/MonadicIteratorMap.js\");\n\n\n\n\n\nconst TEMPLATE_ID = \"calendar-mutation-form\";\nfunction CalendarMutationPage() {}\nCalendarMutationPage.prototype = {\n    paint: async function({ preferredDate, preferredTime }) {\n        let { view } = await this.state;\n        this.anchorElement.setAttribute(\"data-id\", TEMPLATE_ID);\n\n        let preferredDescription, preferredDetails, preferredIsDayOff;\n        {\n            preferredDescription = '';\n            if(preferredDate && preferredTime) {\n                let entriesforDate = view.get(preferredDate);\n                let entriesforDateTime = (\n                    new Map(entriesforDate)\n                ).get(preferredTime);\n                preferredDescription = (\n                    entriesforDateTime.description\n                );\n                preferredDetails = entriesforDateTime.details;\n                preferredIsDayOff = entriesforDateTime.isDayOff;\n            }\n        }\n\n\n        this.getTemplate(TEMPLATE_ID)(\n            this.anchorElement,\n            {\n                \"preferred-date\": preferredDate,\n                \"preferred-time\": preferredTime,\n                \"preferred-description\": preferredDescription,\n                \"preferred-details\": preferredDetails,\n                \"preferred-is-day-off\": preferredIsDayOff ? 'yes' : 'no',\n\n                handleAppCalendarMutationFormSubmit: ({ detail }) => {\n                    const actionRunner = detail;\n                    const action = this.submitCalendarMutation({\n                        preferredDate,\n                        preferredTime\n                    });\n                    return actionRunner(action);\n                },\n\n                handleAppCalendarMutationFormChange: ({ detail }) => {\n                    const { date, time } = detail;\n\n                    this.showConflicts(\n                        {\n                            strTime: time,\n                            strDate: date\n                        },\n                        {preferredDate, preferredTime},\n                        view\n                    );\n                },\n\n                ...this.templateParameters\n            },\n            \"0\"\n        );\n    },\n\n    showConflicts: function(\n        { strTime, strDate },\n        { preferredTime },\n        view\n    ) {\n        let conflicts = [];\n        if(strDate && strTime && preferredTime != strTime) {\n            const entries = (view.get(strDate) || new Map()).entries();\n            conflicts = [...(\n                new _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__.MonadicIteratorMap().filter(\n                    ([candidateTime]) => strTime != preferredTime ? true : candidateTime != preferredTime\n                ).filter(\n                    ([candidateTime]) => (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.strTimeOverlap)(candidateTime, strTime)\n                ).map(\n                    ([candidateTime, eventData]) => (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeData)({\n                        strDate,\n                        strTime: candidateTime,\n                        eventData\n                    })\n                ).apply(entries)\n            )]\n        }\n\n        const maskContainer = this.anchorElement.querySelector(\n            \"*[data-id=conflicts_container]\"\n        );\n        if(conflicts.length) {\n            this.getTemplate(\"calendar-mutation-form_conflicts\")(\n                maskContainer,\n                (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeTemplateScope)(\n                    conflicts,\n                    { sorted: true }\n                ),\n                \"1\"\n            );\n            maskContainer.classList.remove(\"hidden\");\n        } else {\n            maskContainer.classList.add(\"hidden\");\n            maskContainer.innerHTML = \"\";\n        }\n    },\n\n    submitCalendarMutation: function({ preferredDate, preferredTime }) {\n        return async (formData) => {\n            const { cancel } = formData;\n            if(cancel) {\n                await this.cancelEvent({\n                    date: preferredDate,\n                    time: preferredTime\n                });\n            } else {\n                const {\n                    strDate, strTime, isDayOff,\n                    strDescription, strDetails\n                } = formData;\n                if( !preferredDate || !preferredTime || (\n                    preferredDate === strDate && preferredTime === strTime\n                )) {\n                    await this.createEvent({\n                        date: strDate,\n                        time: strTime,\n                        strDescription,\n                        strDetails,\n                        isDayOff\n                    });\n                } else {\n                    await this.editEvent({\n                        toCreate: {\n                            date: strDate,\n                            time: strTime,\n                            strDescription,\n                            strDetails,\n                            isDayOff\n                        },\n                        toCancel: {\n                            date: preferredDate,\n                            time: preferredTime\n                        }\n                    });\n                }\n            }\n\n            this.navigateTo({\n                url: '/calendar-grid',\n                parameters: {}\n            });\n            return undefined;\n        };\n    }\n\n};\n\n/** CREATION PAGE */\n\nfunction CalendarMutationCreatePage() {\n    CalendarMutationPage.call(this);\n}\nCalendarMutationCreatePage.prototype = {\n    templateParameters: {\n        allowCancel: false,\n        pageTitle: \"Créer un rendez-vous\",\n        submitText: \"Créer\"\n    }\n};\nObject.setPrototypeOf(\n    CalendarMutationCreatePage.prototype,\n    CalendarMutationPage.prototype\n);\n\n/** EDITION PAGE  */\n\nfunction CalendarMutationModifyPage() {\n    CalendarMutationPage.call(this);\n}\nCalendarMutationModifyPage.prototype = {\n    templateParameters: {\n        allowCancel: true,\n        pageTitle: \"Modifier le rendez-vous\",\n        submitText: \"Modifier\"\n    }\n};\nObject.setPrototypeOf(\n    CalendarMutationModifyPage.prototype,\n    CalendarMutationPage.prototype\n);\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/CalendarMutationPage.js?");

/***/ }),

/***/ "./src/js/pages/appointment-list/AppointmentDayList.js":
/*!*************************************************************!*\
  !*** ./src/js/pages/appointment-list/AppointmentDayList.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppointmentDayList: () => (/* binding */ AppointmentDayList),\n/* harmony export */   paintAppointmentDayList: () => (/* binding */ paintAppointmentDayList)\n/* harmony export */ });\n/* harmony import */ var _components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/appointments-list/AbstractAppointmentsList.js */ \"./src/js/components/appointments-list/AbstractAppointmentsList.js\");\n/* harmony import */ var _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../algebra/MonadicIteratorMap.js */ \"./src/js/algebra/MonadicIteratorMap.js\");\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../date-utils */ \"./src/js/date-utils.js\");\n\n\n\n\n\n/**\n * @this {AppPage}\n * @param {{ strDate: string }} _ \n * @returns {Promise.<unknown>}\n */\nasync function paintAppointmentDayList({ strDate }) {\n    let { view } = await this.state;\n\n    const date = (0,_date_utils__WEBPACK_IMPORTED_MODULE_2__.validateDateString)(strDate);\n    if(date) {\n        this.anchorElement.setAttribute(\"data-id\", TEMPLATE_ID);\n\n        /**\n         * @type {Map.<TimeString,EventData>}\n         */\n        let source = view.get(date) || new Map();\n\n        this.getTemplate(TEMPLATE_ID)(\n            this.anchorElement,\n            {\n                strDate,\n                menu: {\n                    back: {\n                        handleClick: () => void this.navigateTo({\n                            url: '/calendar/grid',\n                            parameters: {}\n                        })\n                    },\n                    create: {\n                        handleClick: () => void this.navigateTo({\n                            url: '/calendar/mutate/create',\n                            parameters: {\n                                preferredDate: strDate\n                            }\n                        }),\n                    }\n                },\n                hasAppointments: source.size\n            },\n            \"0\"\n        );\n\n        const targetListContainer = this.anchorElement.querySelector(\n            \"*[data-id=appointments_list]\"\n        );\n        if(targetListContainer) {\n            const templateData = (\n                (\n                    /**\n                     * @type {MonadicIteratorMap.<\n                     *  [TimeString, EventData],\n                     *  [TimeString, EventData]\n                     * >}\n                     */ (new _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_1__.MonadicIteratorMap())\n                ).map(\n                    ([strTime, eventData]) => (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_0__.forgeData)({\n                        strDate: date,\n                        strTime,\n                        eventData\n                    }, this.navigateTo)\n                )\n            ).apply(source.entries());\n\n            this.getTemplate(\"appointment_list\")(\n                targetListContainer,\n                (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_0__.forgeTemplateScope)(\n                    templateData,\n                    { sort: true }\n                ),\n                \"1\"\n            );\n        }\n    }\n    return undefined;\n}\n\n\nconst TEMPLATE_ID = \"day-appointments_main\";\nfunction AppointmentDayList() {}\nAppointmentDayList.prototype = {\n    paint: paintAppointmentDayList\n};\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/appointment-list/AppointmentDayList.js?");

/***/ }),

/***/ "./src/js/pages/appointment-list/AppointmentSearchList.js":
/*!****************************************************************!*\
  !*** ./src/js/pages/appointment-list/AppointmentSearchList.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppointmentSearchList: () => (/* binding */ AppointmentSearchList)\n/* harmony export */ });\n/* harmony import */ var _search_engine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../search-engine.js */ \"./src/js/search-engine.js\");\n/* harmony import */ var _components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/appointments-list/AbstractAppointmentsList.js */ \"./src/js/components/appointments-list/AbstractAppointmentsList.js\");\n/* harmony import */ var _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../algebra/MonadicIteratorMap.js */ \"./src/js/algebra/MonadicIteratorMap.js\");\n\n\n\n\n\nconst TEMPLATE_ID = \"appointments-search_main\";\n\nfunction AppointmentSearchList() {}\nAppointmentSearchList.prototype = {\n    paint: async function({ defaultSearchQuery }) {\n        const { view } = await this.state;\n\n        const searchEngine = new _search_engine_js__WEBPACK_IMPORTED_MODULE_0__.SearchEngine();\n        for(const [strDate, timeMap] of view) {\n            for(const [strTime, record] of timeMap) {\n                searchEngine.acceptAppointment({\n                    strDate, strTime,\n                    strDescription: record.description\n                });\n            }\n        }\n\n        this.anchorElement.setAttribute(\"data-id\", TEMPLATE_ID);\n        const self = this;\n        this.getTemplate(TEMPLATE_ID)(\n            this.anchorElement,\n            {\n                handleSubmit: function(e) {\n                    e.preventDefault();\n                    const button = this.querySelector(\"button\");\n                    const searchQuery = this.search.value || '';\n                    if(searchQuery) {\n                        button.disabled = true;\n                        try {\n                            const searchResult = searchEngine.search(\n                                { maximalCount: 10, searchQuery, past: false }\n                            );\n                            \n                            const templateData = (\n                                new _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__.MonadicIteratorMap().map(\n                                    ({ date, time }) => (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeData)({\n                                        strDate: date,\n                                        strTime: time,\n                                        eventData: (\n                                            new Map(view.get(date)).get(time)\n                                        )\n                                    }, self.navigateTo)\n                                )\n                            ).apply(searchResult);\n                \n                            self.getTemplate(\"appointment_list\")(\n                                self.anchorElement.querySelector(\n                                    \"*[data-id=appointments_list]\"\n                                ),\n                                (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeTemplateScope)(\n                                    templateData,\n                                    { sorted: true }\n                                ),\n                                \"1\"\n                            );\n                        } finally {\n                            button.disabled = false;\n                        }\n                    }\n                },\n                hasAppointments: false,\n                defaultSearchQuery,\n                menu: {\n                    back: {\n                        handleClick: () => void this.navigateTo({\n                            url: '/calendar/grid',\n                            parameters: {}\n                        })\n                    },\n                }\n            },\n            \"0\"\n        );\n\n    }\n};\n\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/appointment-list/AppointmentSearchList.js?");

/***/ }),

/***/ "./src/js/pages/appointment-list/UnreadAppointmentList.js":
/*!****************************************************************!*\
  !*** ./src/js/pages/appointment-list/UnreadAppointmentList.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnreadAppointmentList: () => (/* binding */ UnreadAppointmentList)\n/* harmony export */ });\n/* harmony import */ var _date_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../date-utils.js */ \"./src/js/date-utils.js\");\n/* harmony import */ var _components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/appointments-list/AbstractAppointmentsList.js */ \"./src/js/components/appointments-list/AbstractAppointmentsList.js\");\n/* harmony import */ var _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../algebra/MonadicIteratorMap.js */ \"./src/js/algebra/MonadicIteratorMap.js\");\n\n\n\n\n\nconst TEMPLATE_ID = \"unread-appointments_main\";\nfunction UnreadAppointmentList() {}\nUnreadAppointmentList.prototype = {\n    paint: async function() {\n        const { view, newEvents } = await this.state;\n\n        const hasAppointments = !!newEvents.length;\n\n        this.anchorElement.setAttribute(\"data-id\", TEMPLATE_ID);\n        this.getTemplate(TEMPLATE_ID)(\n            this.anchorElement,\n            {\n                menu: {\n                    back: {\n                        handleClick: () => void this.navigateTo({\n                            url: '/calendar/grid',\n                            parameters: {}\n                        })\n                    },\n                    create: {\n                        handleClick: () => void this.navigateTo({\n                            url: '/calendar/mutate/create',\n                            parameters: {\n                                preferredDate: (0,_date_utils_js__WEBPACK_IMPORTED_MODULE_0__.now)()\n                            }\n                        }),\n                    },\n                    markRead: hasAppointments ? {\n                        handleClick: ((self) => async function() {\n                            this.disabled = true;\n                            try {\n                                await self.markRead();\n                                history.back();\n                            } finally {\n                                this.disabled = false;\n                            }\n                        })(this)\n                    } : undefined\n                },\n                hasAppointments\n            },\n            \"0\"\n        );\n\n        if(hasAppointments) {\n            const templateData = (\n                new _algebra_MonadicIteratorMap_js__WEBPACK_IMPORTED_MODULE_2__.MonadicIteratorMap().map(\n                    ({ strDate, strTime }) => (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeData)({\n                        strDate, strTime,\n                        eventData: new Map(view.get(strDate)).get(strTime)\n                    }, this.navigateTo)\n                )\n            ).apply(newEvents);\n\n            this.getTemplate(\"appointment_list\")(\n                this.anchorElement.querySelector(\n                    \"*[data-id=appointments_list]\"\n                ),\n                (0,_components_appointments_list_AbstractAppointmentsList_js__WEBPACK_IMPORTED_MODULE_1__.forgeTemplateScope)(\n                    templateData,\n                    { sorted: true }\n                ),\n                \"1\"\n            );\n        }\n\n    }\n};\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/pages/appointment-list/UnreadAppointmentList.js?");

/***/ }),

/***/ "./src/js/search-engine.js":
/*!*********************************!*\
  !*** ./src/js/search-engine.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchEngine: () => (/* binding */ SearchEngine)\n/* harmony export */ });\n/* harmony import */ var _date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date-utils */ \"./src/js/date-utils.js\");\n\n\n/**\n * @template T - The `yield` type of the base iterator\n */\nclass BatchedIterator\n{\n    /**\n     * @param {Iterator<T, *>} baseIterator \n     */\n    constructor(baseIterator) {\n        this.iterator = baseIterator;\n        this.done = false;\n    }\n\n    /**\n     * @returns {IteratorResult<Array<T>, null>} - An array of elements\n     */\n    next = () => {\n        /**\n         * @type {Array<T>}\n         */\n        const batch = [];\n        if(!this.done) {\n            for(let i = 0; i < 30; i++) {\n                const { done, value } = this.iterator.next();\n                if(!done) {\n                    batch.push(value);\n                } else {\n                    break;\n                }\n            }\n        }\n        if(!batch.length) {\n            this.done = true;\n            return {\n                done: true,\n                value: null\n            };\n        } else {\n            return {\n                value: batch\n            };\n        }\n    };\n\n    [Symbol.iterator] = () => this;\n}\n\n\n/**\n * Extracts words from a text and uniformizes them.\n * \n * Words are detected by finding consecutive sequences of alpha-numeric\n * characters. The uniformization goes through a diphtongue normalization\n * process, described above. A word will never be blank.\n * \n * @param {string} strDescription - The text to extract words from\n * @returns {Set<string>} - The word-tokens\n * ----------------------------------------------------------------------------\n */\nfunction extractTokens(strDescription) {\n    /**\n     * @type{Set<string>}\n     */\n    const tokens = new Set();\n    for(const [match] of strDescription.matchAll(/\\b\\w+\\b/ig)) {\n        const uniformized = uniformizeDiphtongues(match);\n        if(uniformized) {\n            tokens.add(uniformized);\n        }\n    }\n    return tokens;\n}\n\n/**\n * This type defines a substitution result. The first part of the tuple is the\n * text, that will be a suffix. The second part is the prefix.\n * \n * @typedef {[string, string]} Extraction\n * ----------------------------------------------------------------------------\n * \n * Elements of type `Extractor` are expected to return extractions, or nothing\n * if nothing might be extracted. The implementation is specific to each\n * extraction process, yet the common signature is described as:\n * \n * @callback Extractor\n * @param {string} source - The source to extractor from\n * @returns {Extraction=} - The extraction result, or nothing.\n * ----------------------------------------------------------------------------\n */\n\n/**\n * Extract the diphtongue out of the source, if the source starts with the\n * diphtongue. When it is not the case, the method returns undefined.\n * \n * The method does not apply the replacement token, but happens it on the\n * result. This allows an easy pattern-matching with the `undefined` case.\n * \n * @param {string} source - The source text to replace diphtongues in\n * @param {string} diphtongue - The diphtongue to target\n * @param {string} replacement - The replacement string\n * @returns {Extraction=} - A pair of strings\n * ----------------------------------------------------------------------------\n */\nfunction substitute(source, diphtongue, replacement) {\n    if(source.startsWith(diphtongue)) {\n        return [source.slice(diphtongue.length), replacement];\n    } else {\n        return undefined;\n    }\n}\n\n\n/**\n * Extracts the first diphtongue in the source, if found. This method follows\n * the same policy as @link {substitute}, except it applies the additional\n * condition that the next token after the diphtongue, is a vowel or the end\n * of the word.\n * \n * @param {string} source - The source string to replace in\n * @param {string} diphtongue - The diphtongue to target\n * @param {string} replacement - The replacement token for the diphtongue\n * @returns {Extraction=}\n * ----------------------------------------------------------------------------\n */\nfunction substitute_termination(source, diphtongue, replacement) {\n    const length = diphtongue.length;\n    const termination = diphtongue[length - 1];\n    if (source.startsWith(diphtongue)) {\n        substitute: {\n            if(source.length > length) {\n                const charAfterDiphtongue = (\n                    /**\n                     * @type {string} Not null by design\n                     */ (source[length])\n                );\n                if(charAfterDiphtongue == termination\n                    || \"aeiouyh\".includes(charAfterDiphtongue)\n                ) {\n                    break substitute;\n                }\n            }\n            return [source.slice(length), replacement];\n        }\n    }\n    return undefined;\n}\n\n/**\n * Apply transformers onto the source. This auxiliary method is used through the\n * uniformization process.\n * \n * @param {string} source - The text source to apply the transformers onto\n * @param {Iterable<Extractor>} transformers - The transformers to be applied\n * @returns {string} - A text that is the transformed source\n * ----------------------------------------------------------------------------\n */\nfunction applyTransformers(source, transformers) {\n    /**\n     * @type {Array<string>}\n     */\n    const target = [];\n    \n    let sourceCursor = source;\n    while(sourceCursor.length) {\n        applicative: {\n            for(const transformer of transformers) {\n                const transformed = transformer(sourceCursor);\n                if(transformed) {\n                    const [nextSource, newElements] = transformed;\n                    for(const newElement of newElements) {\n                        target.push(newElement);\n                    }\n                    sourceCursor = nextSource;\n                    break applicative;\n                }\n            }\n            const unprocessedLetter = (\n                /**\n                 * @type {string} Not null by design\n                 */ (sourceCursor[0])\n            );\n            target.push(unprocessedLetter);\n            sourceCursor = sourceCursor.slice(1);\n        }\n    }\n    \n    return target.join(\"\");\n}\n\n/**\n * @type {Array<Extractor>}\n */\nconst clean_diphtongues_transformers = [\n    source => { /* Handle C */\n        if(source.startsWith('ch')) {\n            return [source.slice(2), 'C'];\n        } else if(source.startsWith('cc')) {\n            return [source.slice(2), 'x'];\n        } else if(source.startsWith('cq')) {\n            return [source.slice(1), ''];\n        } else if(source.startsWith('ci')) {\n            return [source.slice(1), 's'];\n        } else if(source.startsWith('ce')) {\n            return [source.slice(1), 's'];\n        } else if(source.startsWith('c')) {\n            return [source.slice(1), 'k'];\n        } else {\n            return undefined;\n        }\n    },\n    \n    source => { /* Handle G */\n        if(source.startsWith('gea')) {\n            return [source.slice(2), 'j'];\n        } else if(source.startsWith('geo')) {\n            return [source.slice(2), 'j'];\n        } else if(source.startsWith('gi')) {\n            return [source.slice(1), 'j'];\n        } else if(source.startsWith('gy')) {\n            return [source.slice(1), 'j'];\n        } else if(source.startsWith('ge')) {\n            return [source.slice(1), 'j'];\n        } else if(source.startsWith('gui')) {\n            return [source.slice(2), 'g'];\n        } else if(source.startsWith('guy')) {\n            return [source.slice(2), 'g'];\n        } else if(source.startsWith('gue')) {\n            return [source.slice(2), 'g'];\n        } else {\n            return undefined;\n        }\n    },\n    \n    source => substitute(source, 'qu', 'k'),\n    source => substitute(source, 'q', 'k'),\n    source => substitute(source, 'ph', 'f'),\n    source => substitute(source, 'ille', 'Y'),\n    \n    source => substitute_termination(source, 'on', 'O'),\n    \n    source => substitute_termination(source, 'ain', 'I'),\n    source => substitute_termination(source, 'aim', 'I'),\n    source => substitute(source, 'ai', 'e'),\n    source => substitute_termination(source, 'an', 'A'),\n    source => substitute_termination(source, 'am', 'A'),\n    \n    source => substitute_termination(source, 'ein', 'I'),\n    source => substitute_termination(source, 'eim', 'I'),\n    source => substitute(source, 'ei', 'e'),\n    source => substitute_termination(source, 'en', 'A'),\n    source => substitute_termination(source, 'em', 'A'),\n    \n    source => substitute_termination(source, 'in', 'I'),\n    source => substitute_termination(source, 'im', 'I'),\n    \n    source => substitute(source, 'au', 'o'),\n    source => substitute(source, 'eau', 'o'),\n    source => substitute(source, 'eu', 'E'),\n    source => substitute(source, 'ou', 'U'),\n    \n    source => substitute_termination(source, 'un', 'I'),\n    source => substitute_termination(source, 'um', 'I'),\n    \n    source => substitute(source, 'y', 'i'),\n];\n\n/**\n * @type {Array<Extractor>}\n */\nconst phonem_simplification_transformers = [\n    source => substitute(source, 'tiO', 'siO'),\n    source => substitute(source, 'tiA', 'siA')\n];\n\n/**\n * @type {Array<Extractor>}\n */\nconst post_clean_transformers = [\n    source => { /* Handle doubled letters */\n        if(source.length > 1) {\n            const firstLetter = source[0];\n            if(firstLetter === source[1]) {\n                return [source.slice(1), ''];\n            }\n        }\n        return undefined;\n    },\n    \n    source => substitute(source, 'h', '')\n];\n\n/**\n * List of stop words in French\n */\nconst StopWords = new Set([\n    \"au\",\n    \"aux\",\n    \"avec\",\n    \"ce\",\n    \"ces\",\n    \"dans\",\n    \"de\",\n    \"des\",\n    \"du\",\n    \"elle\",\n    \"en\",\n    \"et\",\n    \"eux\",\n    \"il\",\n    \"je\",\n    \"la\",\n    \"le\",\n    \"leur\",\n    \"lui\",\n    \"ma\",\n    \"mais\",\n    \"me\",\n    \"meme\",\n    \"mes\",\n    \"moi\",\n    \"mon\",\n    \"ne\",\n    \"nos\",\n    \"notre\",\n    \"nous\",\n    \"on\",\n    \"ou\",\n    \"par\",\n    \"pas\",\n    \"pour\",\n    \"qu\",\n    \"que\",\n    \"qui\",\n    \"sa\",\n    \"se\",\n    \"ses\",\n    \"son\",\n    \"sur\",\n    \"ta\",\n    \"te\",\n    \"tes\",\n    \"toi\",\n    \"ton\",\n    \"tu\",\n    \"un\",\n    \"une\",\n    \"vos\",\n    \"votre\",\n    \"vous\",\n    \"c\",\n    \"d\",\n    \"j\",\n    \"l\",\n    \"a\",\n    \"m\",\n    \"n\",\n    \"s\",\n    \"t\",\n    \"y\",\n    \"ete\",\n    \"etee\",\n    \"etees\",\n    \"etes\",\n    \"etant\",\n    \"suis\",\n    \"es\",\n    \"est\",\n    \"sommes\",\n    \"etes\",\n    \"sont\",\n    \"serai\",\n    \"seras\",\n    \"sera\",\n    \"serons\",\n    \"serez\",\n    \"seront\",\n    \"serais\",\n    \"serait\",\n    \"serions\",\n    \"seriez\",\n    \"seraient\",\n    \"etais\",\n    \"etait\",\n    \"etions\",\n    \"etiez\",\n    \"etaient\",\n    \"fus\",\n    \"fut\",\n    \"fumes\",\n    \"futes\",\n    \"furent\",\n    \"sois\",\n    \"soit\",\n    \"soyons\",\n    \"soyez\",\n    \"soient\",\n    \"fusse\",\n    \"fusses\",\n    \"fut\",\n    \"fussions\",\n    \"fussiez\",\n    \"fussent\",\n    \"ayant\",\n    \"eu\",\n    \"eue\",\n    \"eues\",\n    \"eus\",\n    \"ai\",\n    \"as\",\n    \"avons\",\n    \"avez\",\n    \"ont\",\n    \"aurai\",\n    \"auras\",\n    \"aura\",\n    \"aurons\",\n    \"aurez\",\n    \"auront\",\n    \"aurais\",\n    \"aurait\",\n    \"aurions\",\n    \"auriez\",\n    \"auraient\",\n    \"avais\",\n    \"avait\",\n    \"avions\",\n    \"aviez\",\n    \"avaient\",\n    \"eut\",\n    \"eumes\",\n    \"eutes\",\n    \"eurent\",\n    \"aie\",\n    \"aies\",\n    \"ait\",\n    \"ayons\",\n    \"ayez\",\n    \"aient\",\n    \"eusse\",\n    \"eusses\",\n    \"eut\",\n    \"eussions\",\n    \"eussiez\",\n    \"eussent\",\n    \"ceci\",\n    \"cela\",\n    \"cet\",\n    \"cette\",\n    \"ici\",\n    \"ils\",\n    \"les\",\n    \"leurs\",\n    \"quel\",\n    \"quels\",\n    \"quelle\",\n    \"quelles\",\n    \"sans\",\n    \"soi\"\n]);\n\n/**\n * Uniformizes the word in input.\n * \n * Uniformization means that diphtongues will be replaces with an equivalent\n * that makes more sense for comparing words. For examples, \"Constantin\"\n * will be uniformized as \"KOstAtI\", so that it will become closer to\n * phonetically close segments, like \"Kostas\".\n * \n * When a word cannot be uniformizes (because it is too short, or is a\n * stop-word), nothing is returned.\n * \n * @param {string} word - The word to uniformize\n * @returns {string=} A uniformized version of the word, or null.\n * ----------------------------------------------------------------------------\n */\nfunction uniformizeDiphtongues(word) {\n    const lcWord = word.toLocaleLowerCase();\n    if(StopWords.has(lcWord)) {\n        return undefined;\n    } else if(lcWord == \"eau\") {\n        return lcWord;\n    } else {\n        const wordWithoutSpecialChars = (\n            lcWord.replaceAll(\"ç\", \"ss\")\n                .replaceAll(\"ï\", \"hi\")\n                .replaceAll(\"ë\", \"he\")\n                .replaceAll(\"ü\", \"hu\")\n                .replaceAll(\"ö\", \"ho\")\n                .replaceAll(\"ä\", \"ha\")\n                .normalize('NFKD')\n                .replace(/[^\\x20-\\x7F]/g,\"\")\n        );\n        \n        if(wordWithoutSpecialChars.length <= 1) {\n            return undefined;\n        } else {\n            const transformedWord = applyTransformers(\n                applyTransformers(\n                    applyTransformers(wordWithoutSpecialChars,\n                        clean_diphtongues_transformers\n                    ),\n                    phonem_simplification_transformers\n                ),\n                post_clean_transformers\n            );\n            return transformedWord.length <= 1 ? undefined: transformedWord;\n        }\n    }\n}\n\n/**\n * Computes the distance between two letters supposed to represent a\n * diphtongue. In the usual edition-distance algorithm (Levenshtein distance),\n * two letters distinct are always far by 1. We modify this policy, as some\n * letters might be closest to each others than one would expect.\n * \n * The encoding of specific distance associations is done in `RELATED_LETTERS`.\n * \n * Example:\n *  - The distance between \"a\" and \"p\" is 1\n *  - The distance between \"a\" and \"A\" is 0.3\n * \n * @param {string} a - A letter, that represents a diphtongue\n * @param {string} b - A letter, that represents a diphtongue\n * @returns {number} The distance between the letters\n * ----------------------------------------------------------------------------\n */\nfunction letterDistance(a, b) {\n    if(a == b) {\n        return 0;\n    } else {\n        switch(a+b) {\n            case \"oO\": case \"Oo\":\n            case \"uO\": case \"Ou\":\n            case \"aA\": case \"Aa\":\n            case \"eA\": case \"Ae\":\n            case \"eE\": case \"Ee\":\n            case \"uE\": case \"Eu\":\n            case \"iI\": case \"Ii\":\n            case \"iy\": case \"yi\":\n            case \"yI\": case \"Iy\":\n                return 0.3;\n            case \"vf\": case \"fv\":\n            case \"bp\": case \"pb\":\n            case \"td\": case \"dt\":\n            case \"sz\": case \"zs\":\n                return 0.7;\n            default:\n                return 1;\n        }\n    }\n}\n\n/**\n * Recursive variation of the Levenshtein distance between two words.\n * \n * Compared to the usual method, this implementation takes into account\n * specific distances between letters, to reflect more closely the idea of\n * diphtongues. The method also introduces a penalization factor, to short-\n * circuit faster in case the distances are too high.\n * \n * The configuration does not change from one call to another.\n * It is used to allow a short-circuit by upper bound on the distance.\n * It also allows to consider the smallest word being a standard French\n * abbreviation of the longest. As such, the method is not symmetric.\n * We still call it \"distance\", for semantic reasons.\n * \n * @param {string} a - The first word\n * @param {string} b - The second word\n * @param {{distance: number, penalization: number}} stack - Stack\n * @param {{x: string, y:string, upperBound: number}} config - Configuration\n * @returns {number}\n * ----------------------------------------------------------------------------\n */\nfunction _recursiveLevenshtein(a, b, stack, config) {\n    const { distance, penalization } = stack;\n    const { x, y, upperBound } = config;\n\n    if(distance > upperBound || penalization >= 3) {\n        return Infinity;\n    } else if(!a.length) {\n        if(x.length >= 4 && distance <= 1 && x[0] == y[0]) {\n            return distance; // Heuristic: French abbreviation\n        } else {\n            return distance + b.length;\n        }\n    } else if(!b.length) {\n        return distance + a.length;\n    } else if (a[0] === b[0]) {\n        const nextStack=  {\n            distance,\n            penalization: penalization - 1\n        };\n        return _recursiveLevenshtein(\n            a.slice(1), b.slice(1),\n            nextStack, config\n        );\n    } else {\n        const headA = (\n            /**\n             * @type {string}\n             */ (a[0])\n        );\n        const headB = (\n            /**\n             * @type {string}\n             */ (b[0])\n        );\n        const distanceBetweenLetters = letterDistance(headA, headB);\n        const nextStack = {\n            distance: distance + distanceBetweenLetters,\n            penalization: penalization + distanceBetweenLetters >= 0.5 ? 1 : 0\n        };\n        return Math.min(\n            _recursiveLevenshtein(a.slice(1), b.slice(1), nextStack, config),\n            1.1 * _recursiveLevenshtein(a, b.slice(1), nextStack, config),\n            1.1 * _recursiveLevenshtein(a.slice(1), b, nextStack, config),\n        );\n    }\n}\n\n/**\n * This is a public guard to Levenshtein distance. It ensures the first\n * parameter always has smaller length.\n * \n * @param {string} x - First word\n * @param {string} y - Second word\n * @param {number} upperBound - Distance upper bound\n * @returns {number} - The distance between the words\n */\nfunction levenshteinDistance(x, y, upperBound) {\n    if (x.length > y.length) {\n        return levenshteinDistance(y, x, upperBound);\n    } else {\n        const stack = {\n            distance: 0,\n            penalization: 0\n        };\n        const config = { x, y, upperBound };\n\n        return _recursiveLevenshtein(x, y, stack, config);\n    }\n}\n\n\nclass SearchEngine {\n    constructor() {\n        /**\n         * @type {Map<TemporalKeyString, Set<string>>}\n         */\n        this.documents = new Map();\n        /**\n         * @type {Map<string, number>}\n         */\n        this.frequencies = new Map();\n        this.documentCount = 0;\n    }\n    \n    /**\n     * @param {Set<string>} tokens \n     * @param {Map<string, number>} expansion \n     * @param {Set<string>} words \n     * @returns {{distance: number, idf: number }} - The distance and best IDF\n     */\n    #distanceToDocument(tokens, expansion, words) {\n        let scan = [];\n        for(const candidate of expansion.keys()) {\n            if(words.has(candidate)) {\n                const idf = Math.log((1 + this.documentCount) / (\n                    1 + (this.frequencies.get(candidate) || 0)\n                ));\n                const weight = tokens.has(candidate) ? 1. : 0.9;\n                scan.push({weight, idf });\n            }\n        }\n\n        let product = 0.;\n        let closestDistance = 0.;\n        let bestIdf = 0.;\n        for(const {weight, idf} of scan) {\n            product += 0.9 * weight;\n            if(weight > closestDistance) {\n                closestDistance = weight;\n                bestIdf = idf;\n            } else if (weight == closestDistance) {\n                bestIdf = bestIdf < idf ? idf : bestIdf;\n            }\n        }\n        return {\n            distance: product,\n            idf: bestIdf\n        };\n    }\n\n    /**\n     * @param {Set<string>} tokens\n     * @returns {Map<string, number>} \n     */\n    #expansionOfWords(tokens) {\n        /**\n         * @type {Map<string, number>}\n         */\n        const expansion = new Map();\n\n        for(const token of tokens) {\n            for(const candidate of this.frequencies.keys()) {\n                const distance = levenshteinDistance(\n                    token, candidate, 4\n                );\n                if (distance <= Math.min(\n                    4, token.length / 2, candidate.length\n                )) {\n                    const weightSoFar = expansion.get(candidate) || NaN;\n                    const weight = !isFinite(weightSoFar)\n                        ? distance\n                        : Math.min(distance, weightSoFar);\n                    expansion.set(candidate, weight);\n                }\n            }\n        }\n\n        let upperBound = -Infinity;\n        for(const value of expansion.values()) {\n            upperBound = Math.max(upperBound, value);\n        }\n        for(const [key, weight] of expansion.entries()) {\n            expansion.set(key, 1 + upperBound - weight);\n        }\n        for(const token of tokens) {\n            expansion.set(token, 1+upperBound);\n        }\n\n        return expansion;\n    }\n    \n    /**\n     * Accepts a calendar entry and process it in the engine internal state.\n     * \n     * @param {{\n     *  strDate: DateString,\n     *  strTime: TimeString,\n     *  strDescription: string\n     * }} _1 \n     * ------------------------------------------------------------------------\n     */\n    acceptAppointment = (_1) => {\n        const { strDate, strTime, strDescription } = _1;\n        const words = extractTokens(strDescription);\n        const key = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.glueTemporalKey)({\n            date: strDate,\n            time: strTime\n        });\n\n        this.documents.set(key, words);\n        for(const word of words) {\n            const value = this.frequencies.get(word) || 0;\n            this.frequencies.set(word, value + 1);\n        }\n        this.documentCount += 1;\n    };\n\n    /**\n     * Cancels an appointment from the calendar. This means the deletion of\n     * the corresponding entry in the engine internal state.\n     * \n     * @param {{strDate: DateString, strTime: TimeString}} _1\n     * ------------------------------------------------------------------------\n     */\n    cancelAppointment = (_1) => {\n        const key = (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.glueTemporalKey)({\n            date: _1.strDate,\n            time: _1.strTime\n        });\n        this.documents.delete(key);\n    };\n\n    /**\n     * @param {{maximalCount: number, searchQuery: string, past: boolean}} _1\n     * @returns {Array.<TemporalKey>}\n     * ------------------------------------------------------------------------\n     */\n    search = (_1) => {\n        const { maximalCount, searchQuery } = _1;\n        const self = this;\n        const tokens = extractTokens(searchQuery);\n        const expansion = this.#expansionOfWords(tokens);\n\n        /**\n         * @typedef {{\n         *   distance: number,\n         *   idf: number\n         * }} QueueEntry\n         * \n         * @param {QueueEntry} a \n         * @param {QueueEntry} b \n         * @returns {number}\n         */\n        const sortFunction = (a,b) => b.distance == a.distance\n                                ? b.idf - a.idf\n                                : b.distance - a.distance;\n        \n        /**\n         * @type {Array<QueueEntry & {key: TemporalKeyString}>}\n         */\n        let queue = [];\n        let threshold = 0.;\n\n        for(const entries of new BatchedIterator(self.documents.entries())) {\n            for(const [key, words] of entries) {\n                const  { distance, idf } = self.#distanceToDocument(\n                    tokens, expansion, words\n                );\n                if(distance > 0 && distance >= threshold) {\n                    queue.push({ distance, key, idf });\n                }\n            }\n            queue.sort(sortFunction);\n            if(queue.length > maximalCount) {\n                queue = queue.slice(0, maximalCount);\n                threshold = (\n                    /**\n                     * @type{{distance: number}}\n                     * */(queue[maximalCount - 1])\n                ).distance;\n            }\n        }\n\n        return queue.map(({ key }) => (0,_date_utils__WEBPACK_IMPORTED_MODULE_0__.unglueTemporalKey)(key));\n    };\n}\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/search-engine.js?");

/***/ }),

/***/ "./src/js/template-engine.js":
/*!***********************************!*\
  !*** ./src/js/template-engine.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTemplate: () => (/* binding */ getTemplate)\n/* harmony export */ });\n/**\nAuthor: Justin DEKEYSER\nYear: August 2023\n\nUtility file to deal handle hard coded templates, hydratation and\nrehydratation.\n===============================================================================\n*/\n\nconst HANDLED_EVENTS = Object.freeze(new Map([\n    [\"click\", \"handleClick\"],\n    [\"submit\", \"handleSubmit\"],\n    [\"change\", \"handleChange\"],\n    [\"app-authentify\", \"handleAppAuthentify\"],\n    [\"app-calendar-mutation-form-change\",\n                                    \"handleAppCalendarMutationFormChange\"],\n    [\"app-calendar-mutation-form-submit\",\n                                    \"handleAppCalendarMutationFormSubmit\"],\n]));\n\nconst MAX_ALLOWED_DEPTH = 10;\n\nconst OPENING_TOKEN = '{';\nconst CLOSING_TOKEN = '}';\n\nconst SECTION_MARKER = '#';\nconst IF_BLOCK_MARKER = '?';\nconst ELSE_BLOCK_MARKER = ':';\nconst TEXT_CONTENT_MARKER = '$';\nconst EVENT_MARKER = '%';\nconst PIPE_DELIMITER = '|';\nconst HARD_CODED_MARKER = '\"';\nconst END_OF_BLOCK = '/';\n\nconst IDENTIFICATION_ATTRIBUTE = 'data-uuid';\nconst UUID_RANGE = 100_000;\n\nconst BLANK_PATTERN = /\\s\\s+/g;\n\n\n/**\n * Generate a unique UUID, from the knowledge of reserved UUIDs.\n * This method is not secure. The resulting UUID is also happened on\n * the Set, which is thus expected to be mutable.\n * \n * @param {Set<string>} elementUuids - The (mutable) Set of reserved UUID\n * @returns {string} - The generated UUID\n * ----------------------------------------------------------------------------\n */\nfunction generateUuid(elementUuids)\n{\n    for(;;) {\n        const elementUuid = 'uuid'+Math.round(Math.random() * UUID_RANGE);\n        if(!elementUuids.has(elementUuid)) {\n            elementUuids.add(elementUuid);\n            return elementUuid;\n        }\n    }\n}\n\n/**\n * @typedef {(Root & Branch)                        |\n *           (Section & Branch)                     |\n *           (InnerIdentificationSection & Branch)  |\n *           (IfBlock & Branch)                     |\n *           (ElseBlock & Branch)                   |\n *           TextContentDirective                   |\n *           EventDirective                         |\n *           DynamicAttributeDirective              |\n *           HardAttributeDirective                 |\n *           MarkupFragment\n * } Plant - Plant is the union of all possible plant kinds\n * \n * @typedef {Object} Branch - A branch must have space for children\n * @property {Array<Plant>} children - Ordered sequence of subplants\n * \n * @typedef {Object} WithSymbol - A branch must have space for children\n * @property {( 'section'     |\n *              'uuid'        |\n *              'root'        |\n *              'if'          |\n *              'else'        |\n *              'textContent' |\n *              'event'       |\n *              'attribute'   |\n *              'fragment'    )} symbol - Ordered list of subplants\n * \n * @typedef {Object} Root \n * @property {('root')} symbol\n * \n * @typedef {Object} Section\n * @property {('section')} symbol \n * @property {string} variable\n * \n * @typedef {Object} InnerIdentificationSection\n * @property {('uuid')} symbol \n * @property {string} elementUuid\n * \n * @typedef {Object} IfBlock\n * @property {('if')} symbol \n * @property {string} variable\n * \n * @typedef {Object} ElseBlock\n * @property {('else')} symbol \n * @property {string} variable\n * \n * @typedef {Object} TextContentDirective\n * @property {('textContent')} symbol \n * @property {string} variable\n * \n * @typedef {Object} EventDirective\n * @property {('event')} symbol \n * @property {string} variable\n * \n * @typedef {Object} DynamicAttributeDirective\n * @property {('dynamicAttribute')} symbol \n * @property {string} variable\n * @property {string} pipe\n * \n * @typedef {Object} HardAttributeDirective\n * @property {('hardAttribute')} symbol \n * @property {string} value\n * @property {string} pipe\n * \n * @typedef {Object} MarkupFragment\n * @property {('fragment')} symbol \n * @property {string} slice\n */\n\n\n/**\n * Generate a Plant from the template string. The Plant precomputes blocks\n * and prepare them to be rendered. This method is at the core of the\n * templating parsing. It parses the string and creates a tree of nodes that\n * represents actions to perform.\n * \n * The method also takes into account UUID automatic generation for identified\n * sections of the template.\n * \n * @param {string} template - The source template string\n * @param {Set<string>} reservedUuids - Collection of forbidden UUIDs\n * @param {boolean} readOnlySet - Tells if the set can be mutated or not.\n * @returns {Root & Branch} - The template root\n * ----------------------------------------------------------------------------\n */\nfunction generateTreeFromExpression(template, reservedUuids, readOnlySet)\n{\n    if(readOnlySet) {\n        return generateTreeFromExpression(\n            template,\n            new Set(reservedUuids),\n            false\n        );\n    }\n    /** @type {Branch & Root} */\n    const root = {\n        children: [],\n        symbol: 'root'\n    };\n    const elementUuids = reservedUuids;\n    \n    /**\n     * @type {Array<WithSymbol & Branch>}\n     */\n    const ancestorChain = [root];\n    for(let cursor = 0;cursor < template.length;) {\n        if(ancestorChain.length >= MAX_ALLOWED_DEPTH) {\n            throw \"Template is too deep\";\n        }\n        \n        const openingIndex = template.indexOf(OPENING_TOKEN, cursor);\n        const plant = ancestorChain.pop();\n        if(!plant) {\n            throw \"Exhausted ancestor chain\";\n        }\n        \n        if(openingIndex >= 0) {\n            if(cursor + 1 < openingIndex) {\n                const slice = template.substring(\n                    cursor, openingIndex\n                ).replace(BLANK_PATTERN, ' ');\n                emitSlice: {\n                    if(slice === ' ') {\n                        // Heuristic: do not emit spaces\n                        // when they are inside a {#} block.\n                        if(plant.symbol == 'uuid') {\n                            break emitSlice;\n                        } else {\n                            for(let N = ancestorChain.length; --N >= 0;) {\n                                const ancestor = (\n                                    /**\n                                     * @type {WithSymbol} Not null by design\n                                     */ (ancestorChain[N])\n                                );\n                                if(ancestor.symbol == 'uuid') {\n                                    break emitSlice;\n                                }\n                            }\n                        }\n                    }\n\n                    /**\n                     * @type {MarkupFragment}\n                     */\n                    const fragment = {\n                        symbol: 'fragment',\n                        slice\n                    };\n                    plant.children.push(fragment);\n                }\n            }\n\n            const closingIndex = template.indexOf(CLOSING_TOKEN, openingIndex);\n            if(closingIndex == -1) {\n                let estimatedLineNumber = 0;\n                for(const c of template.substring(0, openingIndex)) {\n                    if(c == '\\n') {\n                        estimatedLineNumber += 1;\n                    }\n                }\n                throw `No closing symbol found for opening block; \n                        around line ${estimatedLineNumber}`;\n            }\n            \n            const variable = template.substring(\n                openingIndex+OPENING_TOKEN.length+1, closingIndex\n            ).trim();\n            switch(template[openingIndex+OPENING_TOKEN.length]) {\n                case SECTION_MARKER: {\n                    /**\n                     * @type {(Section | InnerIdentificationSection) & Branch}\n                     */\n                    const nextPlant = variable\n                        ? {\n                            symbol: 'section',\n                            variable,\n                            children: []\n                        } : {\n                            symbol: 'uuid',\n                            elementUuid: generateUuid(elementUuids),\n                            children: []\n                        };\n                    \n                    plant.children.push(nextPlant);\n                    ancestorChain.push(plant);\n                    ancestorChain.push(nextPlant);\n                } break;\n                case IF_BLOCK_MARKER: {\n                    /**\n                     * @type {IfBlock & Branch}\n                     */\n                    const nextPlant = {\n                        symbol: 'if',\n                        variable,\n                        children: []\n                    };\n                    plant.children.push(nextPlant);\n                    ancestorChain.push(plant);\n                    ancestorChain.push(nextPlant);\n                } break;\n                case ELSE_BLOCK_MARKER: {\n                    /**\n                     * @type {ElseBlock & Branch}\n                     */\n                    const nextPlant = {\n                        symbol: 'else',\n                        variable,\n                        children: []\n                    };\n                    plant.children.push(nextPlant);\n                    ancestorChain.push(plant);\n                    ancestorChain.push(nextPlant);\n                } break;\n                case EVENT_MARKER: {\n                    /**\n                     * @type {EventDirective}\n                     */\n                    const leaf = {\n                        symbol: 'event',\n                        variable\n                    };\n                    plant.children.push(leaf);\n                    ancestorChain.push(plant);\n                } break;\n                case TEXT_CONTENT_MARKER: {\n                    /**\n                     * @type {TextContentDirective}\n                     */\n                    const leaf = {\n                        symbol: 'textContent',\n                        variable\n                    };\n                    plant.children.push(leaf);\n                    ancestorChain.push(plant);\n                } break;\n                case END_OF_BLOCK:\n                    break;\n                default: {\n                    const value = template.substring(\n                        openingIndex+OPENING_TOKEN.length, closingIndex\n                    ).trim(); // rectify\n                    const pipeIndex = value.indexOf(PIPE_DELIMITER);\n                    if(pipeIndex == -1) {\n                        let estimatedLineNumber = 0;\n                        for(const c of template.substring(0, openingIndex)) {\n                            if(c == '\\n') {\n                                estimatedLineNumber += 1;\n                            }\n                        }\n                        throw `No pipe delimiter found,\n                            though we reach the end of potential blocks;\n                            around line ${estimatedLineNumber}`;\n                    }\n                    const pipe = value.substring(\n                        pipeIndex+PIPE_DELIMITER.length, value.length\n                    ).trim();\n                    const variable = value.substring(0, pipeIndex).trim();\n                    \n                    /**\n                     * @type {HardAttributeDirective|DynamicAttributeDirective}\n                     */\n                    let leaf;\n                    if(variable.startsWith(HARD_CODED_MARKER)) {\n                        const value = variable.substring(\n                            1, variable.length\n                        ).trim();\n                        leaf = {\n                            symbol: 'hardAttribute',\n                            value, pipe\n                        };\n                    } else {\n                        leaf = {\n                            symbol: 'dynamicAttribute',\n                            variable, pipe\n                        };\n                    }\n\n                    plant.children.push(leaf);\n                    ancestorChain.push(plant);\n                }\n            }\n            \n            cursor = closingIndex + CLOSING_TOKEN.length;\n        } else {\n            /**\n             * @type {MarkupFragment}\n             */\n            const leaf = {\n                symbol: 'fragment',\n                slice: template.substring(\n                    cursor, template.length\n                ).replace(BLANK_PATTERN, ' ')\n            };\n            plant.children.push(leaf);\n            \n            cursor = template.length; // loop is over, so break is not required\n        }\n    }\n    \n    return root;\n}\n\n/**\n * @callback DOMEffect\n * @param {HTMLElement} _\n */\n\n/**\n * @typedef {{\n *  kind: 0,\n *  fragment: string\n * }} FragmentEmission\n * @typedef {{\n *  kind: 1,\n *  identifier: string\n * }} IdentifierEmission\n * @typedef {{\n *  kind: 2,\n *  identifier: string,\n *  sideEffect: DOMEffect,\n *  cancelEffect: DOMEffect\n * }} SideEffectEmission\n * @typedef {FragmentEmission   |\n *           IdentifierEmission |\n *           SideEffectEmission\n * } TemplateSegment\n * @typedef {IteratorResult<TemplateSegment,null>} IteratedTemplateSegment\n */\n\n/**\n * @param {string} identifier\n * @param {DOMEffect} sideEffect\n * @param {DOMEffect} cancelEffect\n * @returns {SideEffectEmission}\n */\nfunction asDOMEffect(identifier, sideEffect, cancelEffect) {\n    return {\n        kind: 2,\n        identifier,\n        sideEffect,\n        cancelEffect\n    };\n}\n\n/**\n * @param {string} fragment\n * @returns {FragmentEmission}\n */\nfunction asFragment(fragment) {\n    return {\n        kind: 0,\n        fragment\n    };\n}\n\n/**\n * @param {string} identifier\n * @returns {IdentifierEmission}\n */\nfunction asIdentification(identifier) {\n    return {\n        kind: 1,\n        identifier\n    };\n}\n\n\n\n/**\n * @param {Object.<string, unknown>} scope - Scope to access property from\n * @param {string | undefined} property - The property to access\n * @returns {unknown}\n */\nfunction _getProperty(scope, property) {\n    if(!property) {\n        throw `Provided property is undefined-- giving up`;\n    }\n    else if(!scope) {\n        throw `Provided scope is undefined (propery ${property}) - giving up`;\n    }\n    else if(!Object.hasOwn(scope, property)) {\n        throw `Scope does not exhibit expected property ${property}`;\n    }\n    else {\n        return scope[property];\n    }\n}\n\n/**\n * @generator\n * @param {Plant} plant - The plant to process\n * @param {Object.<string,unknown>} scope - Scope holding template data\n * @yields {TemplateSegment}\n * @returns {IterableIterator<TemplateSegment>}\n */\nfunction* it(plant, scope) {\n    switch(plant.symbol) {\n        case \"fragment\": {\n            yield asFragment(plant.slice);\n        } break;\n        case \"uuid\": {\n            const uuid = plant.elementUuid;\n            yield asIdentification(uuid);\n            for(const child of plant.children) {\n                for(const emission of it(child, scope)) {\n                    if(emission.kind == 2) {\n                        yield asDOMEffect(\n                            uuid,\n                            emission.sideEffect,\n                            emission.cancelEffect\n                        );\n                    } else {\n                        yield emission;\n                    }\n                }\n            }\n        } break;\n        case \"dynamicAttribute\": {\n            const attributeName = plant.pipe;\n            const value = _getProperty(scope, plant.variable) || '';\n\n            if(!['string', 'boolean', 'number'].includes(typeof value)) {\n                throw `Property ${plant.variable} used as dynamic attribute `\n                    + `must be a a primitive`;\n            } else {\n                const strValue = String(value);\n                if(attributeName == \"class\") {\n                    yield asDOMEffect(\n                        '',\n                        _ => _.classList.add(strValue),\n                        _ => _.classList.remove(strValue)\n                    );\n                } else {\n                    yield asDOMEffect(\n                        '',\n                        _ => _.setAttribute(attributeName, strValue),\n                        _ => _.removeAttribute(attributeName)\n                    );\n                }\n            }\n        } break;\n        case \"hardAttribute\": {\n            const attributeName = plant.pipe;\n            const value = plant.value;\n\n            if(attributeName == \"class\") {\n                yield asDOMEffect(\n                    '',\n                    _ => _.classList.add(value),\n                    _ => _.classList.remove(value)\n                );\n            } else {\n                yield asDOMEffect(\n                    '',\n                    _ => _.setAttribute(attributeName, value),\n                    _ => _.removeAttribute(attributeName)\n                );\n            }\n        } break;\n        case \"textContent\": {\n            const textContent = _getProperty(scope, plant.variable) || '';\n            if(![\"string\", \"number\"].includes(typeof textContent)) {\n                throw `Property ${plant.variable} used for textContent `\n                    + `must be a string`;\n            } else {\n                yield asDOMEffect(\n                    '',\n                    _ => (_.textContent = String(textContent)),\n                    _ => (_.textContent = '')\n                );\n            }\n        } break;\n        case \"event\": {\n            const channel = plant.variable;\n            const property = HANDLED_EVENTS.get(channel);\n            const handler = _getProperty(scope, property);\n            if(handler) {\n                if(typeof handler != 'function') {\n                    throw `Property ${property} used as event handler `\n                        + `must be a function`;\n                } else {\n                    yield asDOMEffect(\n                        '',\n                        _ => _.addEventListener(\n                            channel,\n                            /** @type {EventListener} */ (handler)\n                        ),\n                        _ => _.removeEventListener(\n                            channel,\n                            /** @type {EventListener} */ (handler)\n                        )\n                    );\n                }\n            }\n        } break;\n        case \"if\": {\n            const flag = !!_getProperty(scope, plant.variable);\n            if(flag) {\n                for(const child of plant.children) {\n                    yield* it(child, scope);\n                }\n            }\n        } break;\n        case \"else\": {\n            const flag = !_getProperty(scope, plant.variable);\n            if(flag) {\n                for(const child of plant.children) {\n                    yield* it(child, scope);\n                }\n            }\n        } break;\n        case \"section\": {\n            const value = (\n                /**\n                 * @type {*}\n                 */ (_getProperty(scope, plant.variable))\n            );\n            if(value) {\n                if(typeof value[Symbol.iterator] == 'function') {\n                    let index = 0;\n                    for(const subScope of value) {\n                        for(const child of plant.children) {\n                            for(const emission of it(child, subScope)) {\n                                if(emission.kind == 0) {\n                                    yield emission;\n                                } else {\n                                    const newIdentifier = (\n                                        `${emission.identifier}_${index}`\n                                    );\n                                    if(emission.kind == 2) {\n                                        yield asDOMEffect(\n                                            newIdentifier,\n                                            emission.sideEffect,\n                                            emission.cancelEffect\n                                        );\n                                    } else if(emission.kind == 1) {\n                                        yield asIdentification(\n                                            newIdentifier\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                        index += 1;\n                    }\n                } else {\n                    for(const child of plant.children) {\n                        yield* it(child, value);\n                    }\n                }\n            }\n        } break;\n        default: throw `Unsupported plant symbol ${plant.symbol}`;\n    }\n}\n\n/**\n * The `prefix` attribute will be prefixed on every element that requires to\n * be identified. This can be used by components to enforce a kind of\n * uniqueness they can control, in case they want to reuse the same compiled\n * template in different contexts.\n * \n * @param {string} template\n * @returns \n */\nfunction compile(template)\n{\n    /**\n     * @type {Root & Branch}\n     */\n    const root = generateTreeFromExpression(\n        template, new Set(), false\n    );\n    \n    /**\n     * @param {*} domRoot \n     * @param {*} scope \n     * @param {string} prefix\n     * @yields {undefined}\n     * @returns {*}\n     */\n    const Hydrate = function* (domRoot, scope, prefix)\n    {\n        const sideEffects = new Map();        \n        /* hydratation not done yet */\n        {\n            const htmlFragments = [];\n            for(const plant of root.children) {\n                for(const emission of it(plant, scope)) {\n                    if(emission.kind == 0) {\n                        htmlFragments.push(emission.fragment);\n                    } else {\n                        const identifier = `id${prefix}_${emission.identifier}`;\n                        if(emission.kind == 1) {\n                            htmlFragments.push(\n                                ` ${IDENTIFICATION_ATTRIBUTE}=\"${identifier}\" `\n                            );\n                        } else {\n                            if(!sideEffects.has(identifier)) {\n                                sideEffects.set(identifier, []);\n                            }\n                            sideEffects.get(identifier).push({\n                                sideEffect: emission.sideEffect,\n                                cancelEffect: emission.cancelEffect\n                            });\n                        }\n                    }\n                }\n            }\n            domRoot.innerHTML = htmlFragments.join(\"\");\n        }\n        \n        for(;;) {\n            // Start of the loop, we know the DOM is ready\n            // and sideEffects map is filled but not applied yet\n            \n            // STEP 1: Perform the side effects\n            for(const [identifier, effects] of sideEffects) {\n                const element = domRoot.querySelector(\n                    `*[${IDENTIFICATION_ATTRIBUTE}=${identifier}]`\n                );\n                for(const pair of effects) {\n                    pair.sideEffect(element);\n                    delete pair.sideEffect;\n                }\n            }\n            \n            /*\n            IMPORTANT NOTE:\n            ---------------\n                With the use of DOMPurify, some elements are removed and\n                replaced by their textual values. For example, this directive\n                    <app-foo {#}{\" bar | bar}{/}></app-foo>\n                used to be rendered as\n                    <app-foo></app-foo>\n                with an additional side-effect\n                    setAttribute(\"bar\", \"bar\");\n\n                With the introduction of DOMPurify, the above is still true\n                but *then* the DOM fragment is cleaned and the result actually\n                becomes\n                    \"bar\"\n                (taking as asusmption <app-foo> simply prints its content\n                without further action).\n\n                This effect might not be desired at all. For example,\n                if the custom element is meant to be kept alive, maybe it should\n                not get removed out of the DOM.\n\n                We therefore *do not* process DOMPurify here, but we\n                delegate on another compilation unit that abandon rehydratation\n                and other features custom elements might offer.\n\n                It is always possible to mix both approaches and do something\n                more secure, but this would be opinionated and we prefer to\n                expose a reusable piece, than making a decision that might\n                cost us later.\n            */\n\n\n            // STEP 2: yield nothing and wait for next scope to show up\n            const nextScope = yield;\n            \n            // STEP 3: perform clean\n            for(const [identifier, effects] of sideEffects) {\n                const element = domRoot.querySelector(\n                    `*[${IDENTIFICATION_ATTRIBUTE}=${identifier}]`\n                );\n                for(;;) {\n                    const effect = effects.pop();\n                    if(effect) {\n                        effect.cancelEffect(element);\n                    } else {\n                        break;\n                    }\n                }\n            }\n            \n            if(!nextScope) {\n                // STEP 4b: when no scope, we stop\n                break;\n            } else {\n                // STEP 4: Iterate on the scope again,\n                // populate the effects map again\n                for(const plant of root.children) {\n                    for(const emission of it(plant, scope)) {\n                        if(emission.kind == 2) {\n                            const identifier = (\n                                `id${prefix}_${emission.identifier}`\n                            );\n                            if(!sideEffects.has(identifier)) {\n                                sideEffects.set(identifier, []);\n                            }\n                            sideEffects.get(identifier).push({\n                                sideEffect: emission.sideEffect,\n                                cancelEffect: emission.cancelEffect\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    };\n    return Hydrate;\n}\n\n\n/**\n * This method is a variation of `compile`, where we compile only\n * once without allowing rehydratation. The resulting DOM, however, is\n * purified using DOMPurify.\n * \n * This method fails if DOMPurify is not available.\n * \n * The result might contain an extra `div` container.\n * \n * @param {string} template \n * @returns {HydrateMethod}\n */\nfunction safeCompileOnce(template)\n{\n    const DOMPurify = (\n        /**\n         * @type {*} - DOMPurify interface\n         */ (window)\n    ).DOMPurify;\n    if(!DOMPurify) {\n        throw \"DOMPurify library is required to use this method.\";\n    } else {\n        const BaseHydrate = compile(template);\n\n        /**\n         * @type {HydrateMethod}\n         */\n        const Hydrate = (domRoot, scope, prefix) => {\n            const phantom = document.createElement(\"div\");\n            BaseHydrate(phantom, scope, prefix).next();\n\n            /**\n             * @callback DOMPredicate\n             * @param {string} name\n             * @returns {boolean}\n             */\n\n            DOMPurify.sanitize(phantom, {\n                IN_PLACE: true,\n                CUSTOM_ELEMENT_HANDLING: {\n                    // allow all tags starting with \"app-\"\n                    tagNameCheck: (/** @type {DOMPredicate} */(\n                        (tagName) => !!tagName.match(/^app-/)\n                    )), \n                    // allow all containing \"baz\"\n                    attributeNameCheck: (/** @type {DOMPredicate} */(\n                        () => true\n                    )),// allow customized built-ins\n                    allowCustomizedBuiltInElements: true, \n                }\n            });\n            domRoot.innerHTML = \"\";\n            domRoot.appendChild(phantom);\n\n            return undefined;\n        };\n\n        return Hydrate;\n    }\n}\n\n\nconst Templates =\n{\n    __compiledTemplates: new Map(),\n    /**\n     * Get a template from its ID. This method performs a DOM look-up\n     * to extract the corresponding template text, and stores the compile\n     * result in memoized map.\n     * \n     * @param {string} templateId \n     * @returns {HydrateMethod}\n     * ------------------------------------------------------------------------\n     */\n    getTemplate: function(templateId)\n    {\n        const memo = this.__compiledTemplates;\n        if(!memo.has(templateId)) {\n            const getAppTemplate = (\n                /**\n                 * @type {*}\n                 */ (window)\n            )[\"getAppTemplate\"];\n            const templateString = (\n                /**\n                 * @type {string}\n                 */\n                (getAppTemplate(templateId))\n            );\n            const templateFunction = safeCompileOnce(templateString);\n            memo.set(templateId, templateFunction);\n        }\n        return memo.get(templateId);\n    }\n};\n\n\n/**\n * Get a template from its ID. This method performs a DOM look-up\n * to extract the corresponding template text, and stores the compile\n * result in memoized map.\n * ------------------------------------------------------------------------\n */\n\n/**\n * @type {TemplateGetter}\n */\nfunction getTemplate(templateId) {\n    return Templates.getTemplate(templateId);\n}\n\n\n\n\n//# sourceURL=webpack://v4/./src/js/template-engine.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;